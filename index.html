<!DOCTYPE html>
<html lang="hr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Index</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>


  
</head>
<body>

    <header>
        <div id="user-name">Pozdrav, <span id="ime"></span></div>
        <div id="current-price">Your wallet: <span id="amount">0.00</span> &#948;</div>

    
        <!-- Toggle dugme za mobilne ureƒëaje -->
        <button id="toggle-menu-button" class="toggle-button">‚ò∞</button>
    
        <button id="desktop-toggle-button" class="toggle-button">
            <span class="material-icons">menu</span> 
        </button>
        <nav id="desktop-menu" class="hidden">
            <!-- Desktop meni -->
            <a href="#"><span class="material-icons">home</span> Home</a>
            <a href="#"><span class="material-icons">group</span> Team</a>
            <a href="whitepaper.html"><span class="material-icons">description</span> Whitepaper</a>
            <a href="#" id="chat-link"><span class="material-icons">chat</span> Chat</a>
            <a href="#" id="games-link">
                <span class="material-icons">sports_esports</span> Games
            </a>
            
            <a href="#"><span class="material-icons">person</span> Profile</a>
            <a href="#" id="exchange-link"><span class="material-icons">swap_horiz</span> Exchange</a>
            <a href="#" id="buy-delta-link"><span class="material-icons">attach_money</span> Buy Delta Coin</a>
        </nav>
        
    
        <!-- Mobilni meni -->
        <nav id="toggle-menu">
            <a href="#"><span class="material-icons">home</span> Home</a>
            <a href="#"><span class="material-icons">group</span> Team</a>
            <a href="whitepaper.html"><span class="material-icons">description</span> Whitepaper</a>
            <a href="#" id="chat-link"><span class="material-icons">chat</span> Chat</a>
            <a href="#" id="games-link">
                <span class="material-icons">sports_esports</span> Games
            </a>
            
            <a href="#"><span class="material-icons">person</span> Profile</a>
            <a href="#" id="exchange-link-mobile"><span class="material-icons">swap_horiz</span> Exchange</a>
            <a href="#" id="buy-delta-link-mobile"><span class="material-icons">attach_money</span> Buy Delta Coin</a>

        </nav>
    </header>


   

    <!-- Va≈° postojeƒái kod -->

<div id="chat-modal">
    <div id="chat-header">
        <button id="back-to-users" style="display: none;">‚Üê</button>
        <div id="chat-header-title-container">
            <span id="chat-header-title">Chat with [User]</span>
            <div id="group-members" style="font-size: smaller; color: rgba(0, 0, 0, 0.6);"></div>
        </div>
        <button id="close-chat">‚úï</button>
    </div>
    
    
    
    <div id="chat-box">
        <div id="search-container">
            <input type="text" id="user-search" placeholder="Search users...">
            <button id="search-button">üîç</button>
            <button id="create-group-button"><span class="material-icons">group_add</span></button>
        </div>
       
        <div id="users-list"></div>

        <div id="messages" style="display: none;"></div>
        <div id="message-input" style="display: none;">
            <button id="send-image">+</button>
            <button id="start-game" style="width: 40px; height: 40px; font-size: 20px; background-color: rgba(0, 0, 0, 0.1); border: none; border-radius: 5px; cursor: pointer;">
                <span class="material-icons">sports_esports</span>
            </button>
            <button id="start-audio-call"><span class="material-icons">call</span> Audio Call</button>

            <button id="start-call"><span class="material-icons">videocam</span></button>
            <input type="text" id="chat-message" placeholder="Unesite poruku">
            <button id="send-message">Po≈°alji</button>
        </div>
    </div>
</div>

<!-- Modal za kreiranje grupnog chata -->
<div id="create-group-modal" class="modal" style="display: none;">
    <div class="modal-content">
        <h3 style="color: black;">Kreiraj grupni chat</h3>

        <div id="group-friends-list"></div>
        <label for="group-name">Naziv grupe:</label>
        <input type="text" id="group-name" placeholder="Unesite naziv grupe">
        <button id="create-group-chat-button">Kreiraj grupu</button>
        <button id="cancel-create-group">Otka≈æi</button>
        <label for="group-image">Dodaj sliku grupe:</label>
<input type="file" id="group-image" accept="image/*">

    </div>
</div>

<!-- Ostatak va≈°eg postojeƒáeg HTML koda -->

    
   <!-- Modal for full-screen image -->
<div id="image-modal" class="image-modal">
    <span id="close-image-modal" class="close">&times;</span>
    <img class="modal-content" id="full-screen-image">
</div>


<!-- Exchange Modal -->
<div id="exchange-modal" class="modal">
    <div class="modal-content">
        <span class="close" id="close-exchange-modal">&times;</span>
        <h3>Exchange Delta Coins</h3>
        
<p style="font-size: 0.9em; color: gray;">1 Delta Coin = 0.05247 USD</p>

        
<label for="coin-amount" style="color: black;">How much Delta Coins you want to change:</label>
<input type="number" id="coin-amount" placeholder="Minimum 50" min="50" required>

<p style="color: black;">How much money you will receive:</p>
<p id="usd-amount">0.00 USD</p>

        
        <button id="send-request">Send Request</button>
    </div>
</div>


<!-- Buy Delta Coin Modal -->
<div id="buy-delta-modal" class="modal">
    <div class="modal-content">
        <span class="close" id="close-buy-delta-modal">&times;</span>
        <h3>Buy Delta Coin</h3>
        
        <p style="font-size: 0.9em; color: gray;">1 USD = 19.06 Delta Coins</p> <!-- 1 / 0.05247 za izraƒçun -->
        
        <label for="usd-amount-buy" style="color: black;">How much money you want to change:</label>
<input type="number" id="usd-amount-buy" placeholder="Minimum 5 USD" min="5" required>

<p style="color: black;">How much Delta Coins you will receive:</p>
<p id="delta-amount-receive">0.00 Delta Coins</p>

        
        <button id="buy-delta-button">Buy</button>
    </div>
</div>


<p style="color: black;">${requesterName} invites you to play Tic Tac Toe. Do you accept?</p>

<div id="tic-tac-toe-board" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 10px; z-index: 1000; color: black;">
    <h3 style="text-align: center; color: black;">Tic Tac Toe</h3>
    <div class="board" style="display: grid; grid-template-columns: repeat(3, 100px); gap: 5px;">
        <div class="cell" data-index="0" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="1" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="2" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="3" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="4" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="5" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="6" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="7" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
        <div class="cell" data-index="8" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer; color: black;"></div>
    </div>
    <button id="close-game" style="margin-top: 10px; color: black;">Zatvori igru</button>
</div>




<script>
    document.addEventListener('click', function(event) {
    if (event.target.tagName === 'IMG' && event.target.parentElement.classList.contains('message')) {
        const modal = document.getElementById('image-modal');
        const modalImg = document.getElementById('full-screen-image');
        modal.style.display = 'block';
        modalImg.src = event.target.src; // Set the image source to the clicked image
    }
});

// Close the modal when the close button is clicked
document.getElementById('close-image-modal').addEventListener('click', function() {
    document.getElementById('image-modal').style.display = 'none';
});

</script>


    
    <script>
        const toggleMenuButton = document.getElementById('toggle-menu-button');
        const toggleMenu = document.getElementById('toggle-menu');

        toggleMenuButton.addEventListener('click', () => {
            // Togglovanje prikaza menija
            if (toggleMenu.style.display === 'flex') {
                toggleMenu.style.display = 'none'; // Sakrij meni
            } else {
                toggleMenu.style.display = 'flex'; // Prika≈æi meni
            }
        });
    </script>

   <script>
    // Selektujte desktop toggle dugme i meni
const desktopToggleButton = document.getElementById('desktop-toggle-button');
const desktopMenu = document.getElementById('desktop-menu');

// Dodajte event listener za prikaz/sakrivanje desktop menija
desktopToggleButton.addEventListener('click', () => {
  desktopMenu.style.display = desktopMenu.style.display === 'block' ? 'none' : 'block';
});

   </script>



<script>
    function scrollToBottom() {
    const messagesDiv = document.getElementById('messages');
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

</script>



    <div class="container">
        <div class="icon-section">
            <div class="icon" id="dolar-icon">
                <span class="material-icons">attach_money</span>
                <span class="amount">0.00/h</span>
            </div>
        </div>
        
        <!-- Dodavanje ikone za broj referral koda ispod trenutne cijene -->
      
        <button id="mint-my-coin">
            <span class="material-icons">rocket_launch</span> Mint My Coins
        </button>
        
        
        <!-- Ikona za dijeljenje -->
        <button id="share-icon">
            <span class="material-icons">share</span> Invite friends
        </button>
    </div>

    <div class="image-container">
        <img src="images/delta.png" alt="Delta Image" style="max-width: 100%; height: auto;">
    </div>


    <div id="total-coins-spent" style="text-align: center; font-size: 24px; margin-top: 20px; color: white;">
        Delta Coins Majning: <span id="coins-spent">0</span>/27,000,000
    </div>
    
    

<!-- Virtuelna tr≈ænica -->
<div id="virtual-marketplace" class="marketplace-outline">
    <h2>Virtuelna tr≈ænica</h2>
    <div id="product-list" class="product-list-container">
        <!-- Individual product boxes will be added here -->
    </div>
</div>







    <div class="partnership-box">
        <p>
            Delta coin is selecting partnerships with crypto-services and general businesses ahead of our Open Network launch. 
            This is a unique, early opportunity for businesses to connect with over 10 million engaged Delta coin fans and become part of Delta‚Äôs rapidly expanding Web3 ecosystem. 
            If your company is interested in partnering with Delta or you‚Äôd like to introduce a business to partner with Delta, tap ‚ÄúPartnerships‚Äù to explore how and why.
        </p>
    </div>

   

    <div class="background blue"></div>
    <div class="background purple"></div>

    <script>
        const shareIcon = document.getElementById('share-icon');

        // Pretpostavljamo da korisniƒçko ime dolazi iz URL parametara ili je veƒá definirano
        const { username: userParam } = getQueryParams();

        // Funkcija za nativno dijeljenje
        shareIcon.addEventListener('click', async () => {
            const shareData = {
                title: 'Poziv za pridru≈æivanje',
                text: `Zdravo, pridru≈æi mi se na https://nftnox.github.io/pi9/registracija.html. Moj kod je ${userParam}`
            };

            try {
                await navigator.share(shareData);
                console.log('Uspje≈°no podijeljeno');
            } catch (err) {
                console.error('Gre≈°ka prilikom dijeljenja:', err);
            }
        });

        // Funkcija za dobijanje parametara iz URL-a
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                ime: params.get('ime'),
                prezime: params.get('prezime'),
                username: params.get('username')
            };
        }
    </script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, doc, getDoc, updateDoc, addDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBKfTE0qZdxVLq0lvmli367_yyqpGK-fPA",
            authDomain: "piii-7844e.firebaseapp.com",
            projectId: "piii-7844e",
            storageBucket: "piii-7844e.appspot.com",
            messagingSenderId: "315770496799",
            appId: "1:315770496799:web:0197d4baf2c8731d88722a",
            measurementId: "G-JH9SDWTS9V"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const storage = getStorage(app);



        let userId = ""; // ID trenutnog korisnika
        let username = ""; // Pravi username korisnika
        let currentPrice = 0.00; // Trenutna cijena korisnika
        
        let lastClickTime = null; // Vrijeme posljednjeg klika
        let referralBonus = 0.01; // Poƒçetni bonus za novog korisnika (0.01 za 5 sekundi)

        const MAX_REFERRALS = 10; // Maksimalan broj korisnika koji mogu koristiti isti referralCode

        async function loadUserId() {
    const userCollection = collection(db, 'network');
    const q = query(userCollection, where("username", "==", userParam));
    const querySnapshot = await getDocs(q);

    if (!querySnapshot.empty) {
        querySnapshot.forEach(doc => {
            userId = doc.id; // Dobijanje ID-a korisnika
            const userData = doc.data();
            username = `${userData.ime} ${userData.prezime}`; // Ime + prezime
            document.getElementById('ime').innerText = username; // Prikazivanje imena korisnika
        });
    } else {
        console.error("Korisnik ne postoji u Firestore-u.");
    }
}


        async function checkReferral(referralCode) {
            const userCollection = collection(db, 'network');
            const q = query(userCollection, where("username", "==", referralCode));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                querySnapshot.forEach(async doc => {
                    const referralOwnerId = doc.id;
                    const referralOwnerData = doc.data();
                    const referralCount = referralOwnerData.referralCount || 0;
                    const usedByUser = referralOwnerData.usedBy || [];

                    if (usedByUser.includes(userId)) {
                        console.log(`Korisnik ${userId} je veƒá iskoristio referral kod.`);
                    } else if (referralCount >= MAX_REFERRALS) {
                        console.log(`Referral kod od korisnika ${referralOwnerData.username} je veƒá iskori≈°ten maksimalno puta.`);
                    } else {
                        const newReferralBonus = 0.01 * (referralCount + 1);

                        console.log(`Referral nagrada dodana korisniku ${referralOwnerData.username}, bonus: ${newReferralBonus}`);

                        await updateDoc(doc.ref, {
                            referralBonus: 0.01 + newReferralBonus,
                            referralCount: referralCount + 1,
                            usedBy: [...usedByUser, userId]
                        });

                        document.getElementById('referral-count').innerText = `${referralCount + 1}/${MAX_REFERRALS}`;
                    }
                });
            }
        }

        async function loadUserData() {                 //glavni dio za trenutnu cijenu//
            const docRef = doc(db, 'network', userId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                currentPrice = docSnap.data().currentPrice || 0.00;
                lastClickTime = docSnap.data().lastClickTime ? docSnap.data().lastClickTime.toDate() : null;
                const userReferralBonus = docSnap.data().referralBonus || 0.01;

                document.getElementById('current-price').querySelector('#amount').innerText = currentPrice.toFixed(2);
             document.querySelector('.amount').innerText = (currentPrice > 0) ? userReferralBonus.toFixed(2) + "/h" : "0.00/h";

                const now = new Date();
                const twentyFourHours = 24 * 60 * 60 * 1000;

                if (lastClickTime) {
                    const elapsed = now - lastClickTime;
                    const increments = Math.floor(elapsed / 5000);
                    currentPrice += increments * userReferralBonus;
                    document.getElementById('amount').innerText = currentPrice.toFixed(2);
                    lastClickTime.setSeconds(lastClickTime.getSeconds() + increments * 5);
                    await updateFirestore(currentPrice, lastClickTime);
                }

                document.getElementById('dolar-icon').addEventListener('click', async () => {
                    const now = new Date();

                    if (!lastClickTime || (now - lastClickTime) >= twentyFourHours) {
                        lastClickTime = now;
                        currentPrice += userReferralBonus;
                        document.querySelector('.amount').innerText = userReferralBonus + "/h";
                        await updateFirestore(currentPrice, lastClickTime);
                    } else {
                        alert("Mo≈æete kliknuti samo jednom svakih 24 sata.");
                    }
                });
            } else {
                console.error("Korisnik ne postoji u Firestore-u.");
            }
        }

        async function updateFirestore(currentPrice, lastClickTime) {
            const docRef = doc(db, 'network', userId);
            try {
                await updateDoc(docRef, {
                    currentPrice: currentPrice,
                    lastClickTime: lastClickTime ? lastClickTime : null
                });
                console.log("Podaci uspje≈°no a≈æurirani.");
            } catch (error) {
                console.error("Gre≈°ka prilikom a≈æuriranja podataka: ", error);
            }
        }

        

//////////////////////////////// TRZNICA/////////////////////////////////
// A≈æuriraj funkciju za uƒçitavanje proizvoda
async function loadProducts() {
    const productCollection = collection(db, 'products');
    const querySnapshot = await getDocs(productCollection);
    const productList = document.getElementById('product-list');
    productList.innerHTML = '';

    if (querySnapshot.empty) {
        productList.innerHTML = 'Nema dostupnih proizvoda.';
        return;
    }

    querySnapshot.forEach(docSnap => {
        const productData = docSnap.data();
        const productId = docSnap.id; // ID proizvoda za identifikaciju

        // Kreiraj div za svaki proizvod
        const productDiv = document.createElement('div');
        productDiv.classList.add('product');

        const productImg = document.createElement('img');
        productImg.src = productData.imageUrl;
        productImg.alt = productData.name;
       

        const productName = document.createElement('div');
        productName.textContent = productData.name;

        const productPrice = document.createElement('div');
        productPrice.textContent = `Price: ${productData.price} Œ¥`;




  // Prika≈æi cijenu u ETH ako postoji
  const productCryptoPrice = document.createElement('div');
    if (productData.cryptoPrice) {
        productCryptoPrice.textContent = `Price: ${productData.cryptoPrice} ETH`;
    }

    const buyWithCryptoButton = document.createElement('button');
buyWithCryptoButton.textContent = 'Buy with Crypto';
buyWithCryptoButton.style.backgroundColor = 'purple';
buyWithCryptoButton.style.color = 'white';
buyWithCryptoButton.style.marginTop = '10px';
buyWithCryptoButton.style.fontSize = '16px'; // Set font size to 14px


    // Omoguƒái MetaMask plaƒáanje
   // Omoguƒái MetaMask plaƒáanje
buyWithCryptoButton.addEventListener('click', async () => {
    // Provjera da li je MetaMask instaliran
    if (typeof window.ethereum !== 'undefined') {
        try {
            // Pove≈æite se sa MetaMask-om i dobijte raƒçune
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            const web3 = new Web3(window.ethereum); // Inicijalizacija web3 objekta

            // Dobijanje trenutnog raƒçuna
            const accounts = await web3.eth.getAccounts();
            const account = accounts[0]; // Prvi raƒçun u nizu
            console.log("Povezan raƒçun:", account);

            // Provjera cijene u ETH
            const ethPrice = productData.cryptoPrice;
            console.log("Cijena u ETH:", ethPrice);

            // Konverzija cijene u wei koristeƒái preciznu konverziju
            const weiValue = web3.utils.toWei(ethPrice.toString(), 'ether');
            console.log("Vrijednost u Wei:", weiValue);

            // Inicijacija transakcije
            const txParams = {
                from: account,
                to: '0x6CB206Ac2FA76dee5eD03253942FE2fda92b48E9', // Ethereum adresa primatelja
                value: weiValue, // Vrijednost u wei
                gas: 21000 // Minimalan gas za slanje
            };

            // Slanje transakcije putem MetaMask-a
            const transactionHash = await web3.eth.sendTransaction(txParams);

            // Ako je transakcija uspje≈°na, a≈æuriraj status proizvoda u Firestore-u
            console.log(`Uspje≈°na uplata! Transakcija: ${transactionHash.transactionHash}`);

            // A≈æuriraj status proizvoda na 'prodato' i dodaj novog vlasnika u Firestore-u
            const productDocRef = doc(db, 'products', productId);
            await updateDoc(productDocRef, {
                sold: true,
                owner: userId,
                ownerName: username // Dodaj ime korisnika kao vlasnika
            });

            // Dodavanje proizvoda u kupovine
            const userPurchasesRef = collection(db, `network/${userId}/purchases`);
            await addDoc(userPurchasesRef, {
                name: productData.name,
                imageUrl: productData.imageUrl,
                price: productData.cryptoPrice,
                purchaseTime: new Date()
            });

            // Promjena boje dugmeta na crvenu i teksta na 'Prodato'
            buyWithCryptoButton.textContent = 'Prodato';
            buyWithCryptoButton.style.backgroundColor = 'red';
            buyWithCryptoButton.disabled = true;

            // Prikaz novog vlasnika ispod 'Prodato'
            ownerDiv.textContent = `Novi vlasnik: ${username}`;
            ownerDiv.style.color = 'white';
            ownerDiv.style.cursor = 'pointer';

            // Klikom na ime vlasnika otvara se njegov profil
            ownerDiv.addEventListener('click', () => {
                window.location.href = `profile.html?ime=${username}`;
            });

            productDiv.appendChild(ownerDiv);

            alert(`Kupili ste ${productData.name} za ${productData.cryptoPrice} ETH!`);
        } catch (error) {
            console.error('Gre≈°ka prilikom MetaMask transakcije:', error);
            alert('Do≈°lo je do gre≈°ke. Poku≈°ajte ponovo.');
        }
    } else {
        alert('Molimo vas da instalirate MetaMask ekstenziju za kori≈°tenje kripto plaƒáanja.');
    }
});








const buyButton = document.createElement('button');
buyButton.textContent = productData.sold ? 'Sold' : 'Buy';
buyButton.style.backgroundColor = productData.sold ? 'red' : 'green';
buyButton.style.color = 'white';
buyButton.style.marginTop = '10px';
buyButton.style.fontSize = '16px'; // Set font size to 16px
buyButton.disabled = productData.sold; // Disable button if the product is sold

        // Element za prikaz novog vlasnika
        const ownerDiv = document.createElement('div');
        if (productData.sold && productData.ownerName) {
            ownerDiv.textContent = `Novi vlasnik: ${productData.ownerName}`;
            ownerDiv.style.color = 'white';
            ownerDiv.style.cursor = 'pointer';

            // Klikom na ime vlasnika otvara se njegov profil
         // U kodu za prikaz novog vlasnika
        // Kada se klikne na ime vlasnika proizvoda
        ownerDiv.addEventListener('click', () => {
    const prijavljeniKorisnik = localStorage.getItem('loggedInUser');
    const trenutnaCijena = document.getElementById('amount').innerText; // Trenutna cijena prijavljenog korisnika
    window.location.href = `profile.html?ime=${productData.ownerName}&loggedInUser=${prijavljeniKorisnik}&trenutnaCijena=${trenutnaCijena}`;
});





        }

        buyButton.addEventListener('click', async () => {
    if (productData.sold) {
        alert('Ovaj proizvod je veƒá prodan.');
        return;
    }

    if (typeof window.ethereum === 'undefined') {
        alert('MetaMask nije instaliran! Molimo vas da ga instalirate.');
        return;
    }

    try {
        // Povezivanje sa MetaMask-om
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        const web3 = new Web3(window.ethereum);

        // Trenutni korisniƒçki raƒçun
        const accounts = await web3.eth.getAccounts();
        const currentAccount = accounts[0];

        // Povezivanje s LUNA token ugovorom
        const lunaTokenContract = new web3.eth.Contract(contractABI, contractAddress);

        // Provjera balansa korisnika
        const userBalance = await lunaTokenContract.methods.balanceOf(currentAccount).call();
        const requiredAmount = web3.utils.toWei(productData.price.toString(), 'ether'); // Pretvaranje cijene u Wei

        if (parseFloat(userBalance) < parseFloat(requiredAmount)) {
            alert('Nemate dovoljno LUNA tokena za ovu transakciju.');
            return;
        }

        // Prijenos tokena prodavcu
        const sellerAddress = '0x6CB206Ac2FA76dee5eD03253942FE2fda92b48E9'; // Adresa prodavca
        await lunaTokenContract.methods
            .transfer(sellerAddress, requiredAmount)
            .send({ from: currentAccount });

        // Prijenos vlasni≈°tva nad NFT-om
        const tokenId = productData.tokenId; // Dodajte tokenId u Firestore prilikom mintanja
        const nftContract = new web3.eth.Contract(nftContractABI, nftContractAddress);
        const currentOwner = await nftContract.methods.ownerOf(tokenId).call();

        if (currentOwner.toLowerCase() !== sellerAddress.toLowerCase()) {
            alert('Gre≈°ka: NFT ne pripada prodavcu!');
            return;
        }

        // Transfer NFT-a
        await nftContract.methods
            .safeTransferFrom(sellerAddress, currentAccount, tokenId)
            .send({ from: sellerAddress });

        // A≈æuriranje Firestore baze podataka za proizvod
        const productDocRef = doc(db, 'products', productId);
        await updateDoc(productDocRef, {
            sold: true,
            owner: userId,
            ownerName: username,
        });

        // Dodavanje proizvoda u kupovine korisnika
        const userPurchasesRef = collection(db, `network/${userId}/purchases`);
        await addDoc(userPurchasesRef, {
            name: productData.name,
            imageUrl: productData.imageUrl,
            price: productData.price,
            purchaseTime: new Date(),
        });

        // Promjena izgleda nakon uspje≈°ne kupovine
        buyButton.textContent = 'Sold';
        buyButton.style.backgroundColor = 'red';
        buyButton.disabled = true;

        // Prikaz vlasnika
        ownerDiv.textContent = `Novi vlasnik: ${username}`;
        ownerDiv.style.color = 'white';
        ownerDiv.style.cursor = 'pointer';
        ownerDiv.addEventListener('click', () => {
            window.location.href = `profile.html?ime=${username}`;
        });
        productDiv.appendChild(ownerDiv);

        alert(`Kupili ste ${productData.name} za ${productData.price} LUNA tokena!`);
    } catch (error) {
        console.error('Gre≈°ka prilikom obrade transakcije:', error);
        alert('Do≈°lo je do gre≈°ke. Poku≈°ajte ponovo.');
    }
});




        productDiv.appendChild(productImg);
        productDiv.appendChild(productName);
        productDiv.appendChild(productPrice);
        productDiv.appendChild(buyButton);
        productDiv.appendChild(ownerDiv); // Dodaj div za vlasnika
        productDiv.appendChild(productCryptoPrice); // Prikaz cijene u ETH
        productDiv.appendChild(buyWithCryptoButton); // Dodaj dugme za kripto plaƒáanje
        productList.appendChild(productDiv);
    });
}

// Pozovi funkciju za uƒçitavanje proizvoda nakon ≈°to se stranica uƒçita
document.addEventListener('DOMContentLoaded', loadProducts);

// Spremi ime prijavljenog korisnika u localStorage
localStorage.setItem('loggedInUser', userParam);

// Povezivanje s NFT ugovorom
const nftContractAddress = "0x96c475e10479018cc028D39c71973470fD19f063"; // Zamijeni s adresom svog ugovora
        const nftContractABI = [
        
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "ERC721IncorrectOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ERC721InsufficientApproval",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "approver",
				"type": "address"
			}
		],
		"name": "ERC721InvalidApprover",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			}
		],
		"name": "ERC721InvalidOperator",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "ERC721InvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "receiver",
				"type": "address"
			}
		],
		"name": "ERC721InvalidReceiver",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			}
		],
		"name": "ERC721InvalidSender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ERC721NonexistentToken",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "recipient",
				"type": "address"
			},
			{
				"internalType": "string",
				"name": "uri",
				"type": "string"
			}
		],
		"name": "mintNFT",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "OwnableInvalidOwner",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "OwnableUnauthorizedAccount",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "approved",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "ApprovalForAll",
		"type": "event"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "previousOwner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "OwnershipTransferred",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "renounceOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			},
			{
				"internalType": "bytes",
				"name": "data",
				"type": "bytes"
			}
		],
		"name": "safeTransferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			},
			{
				"internalType": "bool",
				"name": "approved",
				"type": "bool"
			}
		],
		"name": "setApprovalForAll",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "newOwner",
				"type": "address"
			}
		],
		"name": "transferOwnership",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "currentTokenId",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "getApproved",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "operator",
				"type": "address"
			}
		],
		"name": "isApprovedForAll",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "owner",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "ownerOf",
		"outputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "bytes4",
				"name": "interfaceId",
				"type": "bytes4"
			}
		],
		"name": "supportsInterface",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "uint256",
				"name": "tokenId",
				"type": "uint256"
			}
		],
		"name": "tokenURI",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}

        ];

        const web3 = new Web3(window.ethereum);
        const nftContract = new web3.eth.Contract(nftContractABI, nftContractAddress);


///////////////////////////////////MINT////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const contractAddress = "0x19C16A8eb27Bfd879e3BEB044A2f094568F9F672"; // Nova adresa ugovora
const contractABI = [
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "approve",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [],
		"stateMutability": "nonpayable",
		"type": "constructor"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "allowance",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "needed",
				"type": "uint256"
			}
		],
		"name": "ERC20InsufficientAllowance",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "balance",
				"type": "uint256"
			},
			{
				"internalType": "uint256",
				"name": "needed",
				"type": "uint256"
			}
		],
		"name": "ERC20InsufficientBalance",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "approver",
				"type": "address"
			}
		],
		"name": "ERC20InvalidApprover",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "receiver",
				"type": "address"
			}
		],
		"name": "ERC20InvalidReceiver",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "sender",
				"type": "address"
			}
		],
		"name": "ERC20InvalidSender",
		"type": "error"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "ERC20InvalidSpender",
		"type": "error"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "spender",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Approval",
		"type": "event"
	},
	{
		"inputs": [],
		"name": "mintMyTokens",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transfer",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"anonymous": false,
		"inputs": [
			{
				"indexed": true,
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"indexed": true,
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"indexed": false,
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "Transfer",
		"type": "event"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "from",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "to",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "value",
				"type": "uint256"
			}
		],
		"name": "transferFrom",
		"outputs": [
			{
				"internalType": "bool",
				"name": "",
				"type": "bool"
			}
		],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "user",
				"type": "address"
			},
			{
				"internalType": "uint256",
				"name": "amount",
				"type": "uint256"
			}
		],
		"name": "updateAndMint",
		"outputs": [],
		"stateMutability": "nonpayable",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "owner",
				"type": "address"
			},
			{
				"internalType": "address",
				"name": "spender",
				"type": "address"
			}
		],
		"name": "allowance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "account",
				"type": "address"
			}
		],
		"name": "balanceOf",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "decimals",
		"outputs": [
			{
				"internalType": "uint8",
				"name": "",
				"type": "uint8"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [
			{
				"internalType": "address",
				"name": "",
				"type": "address"
			}
		],
		"name": "earnedBalance",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "MAX_SUPPLY",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "name",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "symbol",
		"outputs": [
			{
				"internalType": "string",
				"name": "",
				"type": "string"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalMinted",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	},
	{
		"inputs": [],
		"name": "totalSupply",
		"outputs": [
			{
				"internalType": "uint256",
				"name": "",
				"type": "uint256"
			}
		],
		"stateMutability": "view",
		"type": "function"
	}
];


const mintButton = document.getElementById('mint-my-coin');

mintButton.addEventListener('click', async () => {
    try {
        if (typeof window.ethereum === 'undefined') {
            alert('MetaMask nije instaliran! Molimo vas da ga instalirate.');
            return;
        }

        // Povezivanje sa MetaMask-om
        await window.ethereum.request({ method: 'eth_requestAccounts' });
        const web3 = new Web3(window.ethereum);

        // Dohvati trenutni raƒçun iz MetaMask-a
        const accounts = await web3.eth.getAccounts();
        const currentAccount = accounts[0];

        // Pove≈æi se sa ugovorom
        const contract = new web3.eth.Contract(contractABI, contractAddress);

        // Dohvati iznos iz Your wallet
        const amountElement = document.getElementById('amount');
        const amountToMint = parseFloat(amountElement.innerText);

        if (amountToMint <= 0) {
            alert('Nemate dovoljno sredstava za mintovanje.');
            return;
        }

        // Konvertuj iznos u najmanju jedinicu (wei)
        const amountInWei = web3.utils.toWei(amountToMint.toString(), 'ether');

        // Kombinovano a≈æuriraj saldo i mintuj tokene
        console.log(`A≈æuriranje i mintovanje sa ${amountToMint} za ${currentAccount}`);
        await contract.methods
            .updateAndMint(currentAccount, amountInWei)
            .send({ from: currentAccount });

        alert(`Uspje≈°no ste mintovali ${amountToMint} LUNA tokena!`);

        // Resetujte `currentPrice` varijablu na 0.00
        currentPrice = 0.00;

        // Resetuj iznos u virtuelnom novƒçaniku na 0
        amountElement.innerText = '0.00';

        // A≈æuriraj Firestore bazu podataka
        await updateFirestore(currentPrice, lastClickTime);

    } catch (error) {
        console.error('Gre≈°ka prilikom mintovanja:', error);
        alert('Do≈°lo je do gre≈°ke. Molimo poku≈°ajte ponovo.');
    }
});




//////////////////////////////////////////////////// Open and close modal for "Exchange"////////////////////////////////////////////////////////////////////////////////
document.getElementById('exchange-link').addEventListener('click', () => {
    document.getElementById('exchange-modal').style.display = 'block';
});
document.getElementById('exchange-link-mobile').addEventListener('click', () => {
    document.getElementById('exchange-modal').style.display = 'block';
});

document.getElementById('close-exchange-modal').addEventListener('click', () => {
    document.getElementById('exchange-modal').style.display = 'none';
});

// Exchange Rate Logic
const coinAmountInput = document.getElementById('coin-amount');
const usdAmountDisplay = document.getElementById('usd-amount');
const exchangeRate = 0.05247; // 1 Delta Coin = 0.05247 USD

coinAmountInput.addEventListener('input', () => {
    const coinAmount = parseFloat(coinAmountInput.value);
    if (coinAmount >= 50) {
        const usdAmount = (coinAmount * exchangeRate).toFixed(2);
        usdAmountDisplay.innerText = `${usdAmount} USD`;
    } else {
        usdAmountDisplay.innerText = "0.00 USD";
    }
});

// Send Request to Firestore
document.getElementById('send-request').addEventListener('click', async () => {
    const coinAmount = parseFloat(coinAmountInput.value);
    if (coinAmount < 50) {
        alert("Please enter at least 50 Delta Coins.");
        return;
    }

    // Calculate USD equivalent
    const usdAmount = (coinAmount * exchangeRate).toFixed(2);

    try {
        // Fetch User ID and currentPrice from Firestore
        const userCollection = collection(db, 'network');
        const q = query(userCollection, where("username", "==", userParam));
        const querySnapshot = await getDocs(q);

        if (!querySnapshot.empty) {
            const userDoc = querySnapshot.docs[0];
            const userId = userDoc.id;
            const currentPrice = parseFloat(userDoc.data().currentPrice);  // Koristi currentPrice kao saldo

            console.log("User Current Price:", currentPrice);
            console.log("Requested Coin Amount:", coinAmount);

            // Check if user has enough Delta Coins
            if (isNaN(currentPrice) || currentPrice < coinAmount) {
                alert(`You don't have enough Delta Coins. Your balance is ${currentPrice}.`);
                return;
            }

            // Save Request to Firestore
            const requestCollection = collection(db, 'request');
            await addDoc(requestCollection, {
                userId: userId,
                coinAmount: coinAmount,
                usdAmount: usdAmount,
                requestDate: new Date()
            });

            alert(`Request sent: ${coinAmount} Delta Coins = ${usdAmount} USD`);
            document.getElementById('exchange-modal').style.display = 'none';
        } else {
            console.error("User not found in Firestore.");
        }
    } catch (error) {
        console.error("Error sending request:", error);
        alert("An error occurred. Please try again.");
    }
});


// Open and close modal for "Buy Delta Coin"
document.getElementById('buy-delta-link').addEventListener('click', () => {
    document.getElementById('buy-delta-modal').style.display = 'block';
});
document.getElementById('buy-delta-link-mobile').addEventListener('click', () => {
    document.getElementById('buy-delta-modal').style.display = 'block';
});
document.getElementById('close-buy-delta-modal').addEventListener('click', () => {
    document.getElementById('buy-delta-modal').style.display = 'none';
});


// Exchange rate for USD to Delta Coin
const usdToDeltaRate = 1 / 0.05247; // 1 USD = 19.06 Delta Coins

// Update Delta Coin amount based on USD input
const usdAmountBuyInput = document.getElementById('usd-amount-buy');
const deltaAmountReceiveDisplay = document.getElementById('delta-amount-receive');

usdAmountBuyInput.addEventListener('input', () => {
    const usdAmount = parseFloat(usdAmountBuyInput.value);
    if (usdAmount >= 5) {
        const deltaAmount = (usdAmount * usdToDeltaRate).toFixed(2);
        deltaAmountReceiveDisplay.innerText = `${deltaAmount} Delta Coins`;
    } else {
        deltaAmountReceiveDisplay.innerText = "0.00 Delta Coins";
    }
});



/////////////////CHAAAAAAAAAAAAAAAAAAAAAAAAAAAAT///////////////////////////////////////////////////////////////////////////////////////////////////////

        let isChatOpen = false; // Pratimo da li je chat otvoren
let selectedUserName = ''; // ƒåuvamo ime trenutno odabranog korisnika
let selectedUserId = ''; // ƒåuvamo ID trenutno odabranog korisnika

// Store all users globally to filter them later
let allUsers = [];
let contacts = new Set(); // Set koristi se za eliminaciju duplikata

// Fetch only the users with whom a chat has been established
async function fetchContacts() {
    const chatRequestCollection = collection(db, 'chatRequests');

    // Upiti za chatove u kojima je korisnik requester ili recipient
    const qRequester = query(chatRequestCollection, where('accepted', '==', true), where('requester', '==', username));
    const qRecipient = query(chatRequestCollection, where('accepted', '==', true), where('recipientName', '==', username));

    contacts.clear(); // Oƒçisti prethodne kontakte

    // Dohvati sve chatove gdje je trenutni korisnik bio requester
    const querySnapshotRequester = await getDocs(qRequester);
    querySnapshotRequester.forEach(doc => {
        const chatData = doc.data();
        const contactUser = allUsers.find(user => user.userName === chatData.recipientName);
        if (contactUser) {
            contacts.add(JSON.stringify(contactUser));
        }
    });

    // Dohvati sve chatove gdje je trenutni korisnik bio recipient
    const querySnapshotRecipient = await getDocs(qRecipient);
    querySnapshotRecipient.forEach(doc => {
        const chatData = doc.data();
        const contactUser = allUsers.find(user => user.userName === chatData.requester);
        if (contactUser) {
            contacts.add(JSON.stringify(contactUser));
        }
    });

    // Prika≈æi sve kontakte sa profilnim slikama
    const uniqueContacts = Array.from(contacts).map(item => JSON.parse(item));
    displayUsers(uniqueContacts); // Prika≈æi kontakte
}


// Funkcija za prikaz korisnika i statusa
// Funkcija za prikaz korisnika i statusa
function displayUsers(users) {
    const usersListDiv = document.getElementById('users-list');
    usersListDiv.innerHTML = ''; // Oƒçisti prethodnu listu

    users.forEach(user => {
        const userElement = document.createElement('div');
        userElement.classList.add('user-item');
        userElement.id = `user-${user.userId}`; // Postavi ID elementa
        userElement.style.display = 'flex';
        userElement.style.alignItems = 'center';
        userElement.style.marginBottom = '10px';

        // Omotaƒç za profilnu sliku, omoguƒáen relativnim pozicioniranjem
        const imgWrapper = document.createElement('div');
        imgWrapper.style.position = 'relative'; // Omoguƒáava pozicioniranje ikone unutar slike

        // Profilna slika ili prazan krug s ikonom
        const imgElement = document.createElement('div');
        imgElement.style.width = '50px';
        imgElement.style.height = '50px';
        imgElement.style.borderRadius = '50%';
        imgElement.style.marginRight = '10px';
        imgElement.style.display = 'flex';
        imgElement.style.justifyContent = 'center';
        imgElement.style.alignItems = 'center';
        imgElement.style.position = 'relative';

        if (user.profilePictureUrl) {
            imgElement.style.backgroundImage = `url(${user.profilePictureUrl})`;
            imgElement.style.backgroundSize = 'cover';
            imgElement.style.backgroundPosition = 'center';
        } else {
            imgElement.style.backgroundColor = '#e0e0e0'; // Svijetlo siva za prazan krug
            imgElement.innerHTML = '<i class="fas fa-user" style="font-size: 20px; color: #7d7d7d;"></i>';
        }

        // Status ikona
        const statusIcon = document.createElement('span');
        statusIcon.classList.add('status-icon');
        statusIcon.style.width = '12px';
        statusIcon.style.height = '12px';
        statusIcon.style.borderRadius = '50%';
        statusIcon.style.backgroundColor = 'gray'; // Zadana boja prije uƒçitavanja statusa
        statusIcon.style.position = 'absolute';
        statusIcon.style.bottom = '3px';
        statusIcon.style.right = '3px';
        statusIcon.style.border = '2px solid white';

        imgWrapper.appendChild(imgElement);
        imgWrapper.appendChild(statusIcon);
        userElement.appendChild(imgWrapper);

        // Korisniƒçko ime
        const userInfo = document.createElement('div');
        userInfo.classList.add('user-info');

        const userName = document.createElement('div');
        userName.classList.add('user-name');
        userName.textContent = user.userName; // Ime + prezime

        const lastMessage = document.createElement('div');
        lastMessage.classList.add('last-message');
        lastMessage.textContent = user.lastMessage || 'Tap to preview';
        lastMessage.style.fontSize = '12px';
        lastMessage.style.color = '#7d7d7d';

        userInfo.appendChild(userName);
        userInfo.appendChild(lastMessage);
        userElement.appendChild(userInfo);

        // Klik za otvaranje chata s korisnikom
        userElement.addEventListener('click', () => {
            checkExistingChatRequest(user.userId, user.userName);
        });

        usersListDiv.appendChild(userElement);
    });
}


// Funkcija za a≈æuriranje statusa korisnika
async function updateUserStatus(userId, statusIcon) {
    const userDocRef = doc(db, 'network', userId);
    const userDoc = await getDoc(userDocRef);

    if (userDoc.exists()) {
        const userData = userDoc.data();
        const lastClickTime = userData.lastClickTime ? userData.lastClickTime.toDate() : null;
        const now = new Date();

        if (lastClickTime) {
            const timeElapsed = now - lastClickTime;

            // Postavi boju ikone na osnovu statusa
            if (timeElapsed < 60000) { // Manje od 1 minuta
                statusIcon.style.backgroundColor = 'green'; // Online
            } else if (timeElapsed < 600000) { // 1 do 10 minuta
                statusIcon.style.backgroundColor = 'yellow'; // Odsutan
            } else {
                statusIcon.style.backgroundColor = 'red'; // Offline
            }
        } else {
            statusIcon.style.backgroundColor = 'red'; // Offline
        }
    }
}

// Periodiƒçno a≈æuriranje statusa svakih 30 sekundi
setInterval(() => {
    const userElements = document.querySelectorAll('.user-item');
    userElements.forEach(userElement => {
        const userId = userElement.id.replace('user-', '');
        const statusIcon = userElement.querySelector('.status-icon');
        updateUserStatus(userId, statusIcon);
    });
}, 30000); // A≈æuriranje svakih 30 sekundi



// Funkcija za pretragu korisnika prilikom unosa
document.getElementById('user-search').addEventListener('input', function () {
    const searchText = this.value.toLowerCase();

    if (searchText === '') {
        // Ako je pretraga prazna, prikazuj samo kontakte
        displayUsers(Array.from(contacts).map(item => JSON.parse(item)));
    } else {
        // Ako postoji unos u pretrazi, filtriraj sve korisnike
        const filteredUsers = allUsers.filter(user => user.userName.toLowerCase().includes(searchText));
        displayUsers(filteredUsers); // A≈æuriraj listu s filtriranim korisnicima
    }
});

// Funkcija za dohvat svih korisnika
async function fetchUsers() {
    const userCollection = collection(db, 'network');
    const querySnapshot = await getDocs(userCollection);

    allUsers = []; // Oƒçisti listu korisnika
    querySnapshot.forEach(doc => {
        const userData = doc.data();
        const userName = `${userData.ime} ${userData.prezime}`; // Kombinacija imena i prezimena
        const userId = doc.id;
        const profilePictureUrl = userData.profilePictureUrl || ''; // Preuzimamo URL slike ako postoji

        allUsers.push({ userName, userId, profilePictureUrl });
    });

    // Nakon dohvaƒáanja svih korisnika, prika≈æi samo one s kojima je zapoƒçet razgovor
    await fetchContacts(); // Prika≈æi samo kontakte
}


// Funkcija za inicijalno uƒçitavanje kada se otvori chat modal
document.getElementById('chat-link').addEventListener('click', async () => {
    await fetchUsers(); // Uƒçitaj sve korisnike, ali prika≈æi samo one s kojima je zapoƒçet razgovor
});



// Funkcija za provjeru postojeƒáeg zahtjeva za chat izmeƒëu dva korisnika
async function checkExistingChatRequest(userId, userName) {
    selectedUserId = userId; // Postavljanje selectedUserId
    selectedUserName = userName;

    // Provera da li je u pitanju grupa
    const isGroup = allUsers.find(user => user.userId === userId && user.isGroup);

    if (isGroup) {
        // Ako je grupa, proverite da li grupa postoji i otvorite je
        console.log(`Otvaram grupu: ${userName}`);
        openGroupChat(userId, userName); // Otvaranje grupnog chata
        return; // Izlazak iz funkcije
    }

    // Nastavak za privatne razgovore
    const chatRequestCollection = collection(db, 'chatRequests');
    const q = query(chatRequestCollection, 
                    where('requester', 'in', [username, userName]), 
                    where('recipientName', 'in', [username, userName]));

    const querySnapshot = await getDocs(q);

    if (!querySnapshot.empty) {
        // Ako veƒá postoji zahtev, prikazujemo prompt za prihvatanje
        querySnapshot.forEach(doc => {
            const requestData = doc.data();
            if (requestData.recipientName === username && !requestData.accepted) {
                showAcceptChatPrompt(requestData.requester, doc.id); // Korisnik prima zahtev
            } else if (requestData.requester === username && !requestData.accepted) {
                alert(`ƒåekate da ${requestData.recipientName} prihvati va≈° zahtev.`);
            } else {
                openChat(userName); // Ako je zahtev veƒá prihvaƒáen, otvaramo chat
            }
        });
    } else {
        // Ako ne postoji zahtev, prika≈æemo prompt za poƒçetak chata
        showChatRequestPrompt(userName, userId);
    }
}


// Funkcija za prikazivanje prozora za poƒçetak chata
function showChatRequestPrompt(userName, userId) {
    // Provjeravamo da li prozor veƒá postoji, da bismo sprijeƒçili dupli prikaz
    let existingPrompt = document.querySelector('.chat-request-prompt');
    if (existingPrompt) {
        document.body.removeChild(existingPrompt);
    }

    const chatRequestPrompt = document.createElement('div');
    chatRequestPrompt.classList.add('chat-request-prompt');
    chatRequestPrompt.style.position = 'fixed';
    chatRequestPrompt.style.top = '50%';
    chatRequestPrompt.style.left = '50%';
    chatRequestPrompt.style.transform = 'translate(-50%, -50%)';
    chatRequestPrompt.style.padding = '20px';
    chatRequestPrompt.style.backgroundColor = 'white';
    chatRequestPrompt.style.border = '1px solid black';
    chatRequestPrompt.style.zIndex = '1000'; // Osiguravamo da je prozor iznad svih ostalih elemenata

    chatRequestPrompt.innerHTML = `
       <p style="color: black;">≈Ωelite li zapoƒçeti chat sa ${userName}?</p>

        <button id="accept-chat-request">Da</button>
        <button id="decline-chat-request">Ne</button>
    `;

    document.body.appendChild(chatRequestPrompt);






    
    // Postavi dogaƒëaj za prihvatanje zahtjeva
    document.getElementById('accept-chat-request').addEventListener('click', () => {
        sendChatRequest(userId, userName);
        document.body.removeChild(chatRequestPrompt); // Ukloni prozor za zahtjev
    });

    // Postavi dogaƒëaj za odbijanje zahtjeva
    document.getElementById('decline-chat-request').addEventListener('click', () => {
        document.body.removeChild(chatRequestPrompt); // Ukloni prozor za zahtjev
    });
}

// Funkcija za prikazivanje prozora za prihvatanje chata
function showAcceptChatPrompt(requesterName, requestId) {
    const chatAcceptPrompt = document.createElement('div');
    chatAcceptPrompt.classList.add('chat-accept-prompt');
    chatAcceptPrompt.style.position = 'fixed';
    chatAcceptPrompt.style.top = '50%';
    chatAcceptPrompt.style.left = '50%';
    chatAcceptPrompt.style.transform = 'translate(-50%, -50%)';
    chatAcceptPrompt.style.padding = '20px';
    chatAcceptPrompt.style.backgroundColor = 'white';
    chatAcceptPrompt.style.border = '1px solid black';
    chatAcceptPrompt.style.zIndex = '1000'; // Osiguravamo da je prozor iznad svih ostalih elemenata

    chatAcceptPrompt.innerHTML = `
       <p style="color: black;">Korisnik ${requesterName} ≈æeli da zapoƒçne chat sa vama. Prihvatate li?</p>

        <button id="accept-chat-${requestId}">Prihvati</button>
        <button id="decline-chat-${requestId}">Odbij</button>
    `;

    document.body.appendChild(chatAcceptPrompt);

    // Prihvati zahtjev
    document.getElementById(`accept-chat-${requestId}`).addEventListener('click', () => {
        acceptChatRequest(requestId);
        document.body.removeChild(chatAcceptPrompt); // Ukloni obavje≈°tenje
    });

    // Odbij zahtjev
    document.getElementById(`decline-chat-${requestId}`).addEventListener('click', () => {
        document.body.removeChild(chatAcceptPrompt); // Ukloni obavje≈°tenje
    });
}

// Funkcija za slanje zahtjeva za chat
async function sendChatRequest(userId, userName) {
    try {
        const chatRequestCollection = collection(db, 'chatRequests');
        await addDoc(chatRequestCollection, {
            requester: username, // Logovani korisnik
            recipientId: userId, // ID korisnika kojem ≈°aljemo zahtjev
            recipientName: userName,
            accepted: false // Po defaultu nije prihvaƒáen
        });
        console.log("Zahtjev za chat uspje≈°no poslan.");
    } catch (error) {
        console.error("Gre≈°ka prilikom slanja zahtjeva:", error);
    }
}

// Funkcija za prihvatanje zahtjeva za chat
async function acceptChatRequest(requestId) {
    const requestDocRef = doc(db, 'chatRequests', requestId);
    try {
        await updateDoc(requestDocRef, { accepted: true });
        console.log("Zahtjev za chat prihvaƒáen.");
        openChat(selectedUserName); // Omoguƒái normalan chat nakon prihvatanja
    } catch (error) {
        console.error("Gre≈°ka prilikom prihvatanja zahtjeva:", error);
    }
}






// Event listener za desktop meni
// Event listener za otvaranje chat modal prozora
document.getElementById('chat-link').addEventListener('click', async () => {
    const chatModal = document.getElementById('chat-modal');
    chatModal.style.display = 'flex'; // Prikaz modalnog prozora

    if (!isChatOpen) {
        await fetchUsers();       // Dohvati 1-na-1 kontakte
        await fetchUserGroups();   // Dohvati grupe
        isChatOpen = true;         // Postavi chat kao otvoren
    } else {
        resetChat(); // Resetuj ako je veƒá otvoren
    }
});


// Dodaj event listener za chat link u mobilnom meniju
// Event listener for mobile toggle menu to open chat modal with contacts and groups
document.getElementById('toggle-menu').addEventListener('click', async (event) => {
    if (event.target.id === 'chat-link') {
        document.getElementById('toggle-menu').style.display = 'none'; // Hide mobile menu
        const chatModal = document.getElementById('chat-modal');
        chatModal.style.display = 'flex'; // Display chat modal

        if (!isChatOpen) {
            await fetchUsers();       // Fetch individual user contacts
            await fetchUserGroups();   // Fetch group chats
            isChatOpen = true;         // Mark chat as open
        } else {
            resetChat(); // Reset chat if it‚Äôs already open
        }
    }
});







function openChat(userName) {
    selectedUserName = userName;

    // Pronaƒëite ID korisnika na osnovu imena
    const user = allUsers.find(u => u.userName === userName);
    if (user) {
        selectedUserId = user.userId;
    } else {
        console.error('User not found');
    }

    // Sakrijte pretragu korisnika
    const searchContainer = document.getElementById('search-container');
    searchContainer.style.display = 'none';

    // Prika≈æite poruke i unos poruka
    const messagesDiv = document.getElementById('messages');
    const messageInputDiv = document.getElementById('message-input');
    const usersListDiv = document.getElementById('users-list');
    const backButton = document.getElementById('back-to-users');
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const groupMembersDiv = document.getElementById('group-members');

    usersListDiv.style.display = 'none';
    messagesDiv.style.display = 'block';
    messageInputDiv.style.display = 'flex';

    // Postavljanje naslova u zaglavlju chata
    chatHeaderTitle.innerHTML = ` ${userName} 
    <span id="start-audio-call" title="Audio Call" style="margin-left: 10px; cursor: pointer;">
        <span class="material-icons">call</span>
    </span>
    <span id="start-call" title="Video Call" style="margin-left: 5px; cursor: pointer;">
        <span class="material-icons">videocam</span>
    </span>
`;


    backButton.style.display = 'block';

    // Sakrij i oƒçisti 'group-members' div
    if (groupMembersDiv) {
        groupMembersDiv.innerText = '';
        groupMembersDiv.style.display = 'none';
    }

    // Prazan 'groupId' u zaglavlju
    chatHeaderTitle.dataset.groupId = '';

    // Uƒçitajte historiju poruka i postavite oslu≈°kivanje za nove poruke
    loadMessageHistory();
    listenForNewMessages();

    // Dodajte event listenere za dugmad za audio i video poziv
    document.getElementById('start-audio-call').addEventListener('click', async () => {
        if (!selectedUserId || !selectedUserName) {
            console.error('selectedUserId ili selectedUserName nisu postavljeni');
            return;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            await startAudioCall(selectedUserId, selectedUserName, stream);
        } catch (error) {
            console.error('Gre≈°ka prilikom pokretanja audio poziva:', error);
        }
    });

    document.getElementById('start-call').addEventListener('click', async () => {
        if (!selectedUserId || !selectedUserName) {
            console.error('selectedUserId ili selectedUserName nisu postavljeni');
            return;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            await startCall(selectedUserId, selectedUserName, stream);
        } catch (error) {
            console.error('Gre≈°ka prilikom pokretanja video poziva:', error);
        }
    });
}







async function loadMessageHistory() {
    const messagesCollection = collection(db, 'poruke');
    const q = query(messagesCollection, 
        where('sender', 'in', [username, selectedUserName]),
        where('recipient', 'in', [username, selectedUserName])
    );
    const querySnapshot = await getDocs(q);
    
    const messagesDiv = document.getElementById('messages');
    messagesDiv.innerHTML = ''; // Oƒçisti prethodne poruke

    // Uƒçitaj poruke u niz i sortiraj po timestamp-u
    const messages = [];
    querySnapshot.forEach(doc => {
        const messageData = doc.data();
        messages.push({
            ...messageData,
            id: doc.id // Saƒçuvaj id za kasniju upotrebu ako je potrebno
        });
    });

    // Sortiraj poruke po timestamp-u
    messages.sort((a, b) => a.timestamp - b.timestamp);

    // Prika≈æi sortirane poruke
    messages.forEach(messageData => {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message');

        // Provjeravamo da li je poruka slika
        if (messageData.isImage) {
            const imgElement = document.createElement('img');
            imgElement.src = messageData.message; // Postavi URL slike
            imgElement.style.maxWidth = '200px'; // Maksimalna ≈°irina slike
            imgElement.style.borderRadius = '10px'; // Zaobljeni uglovi (opciono)
            imgElement.style.marginBottom = '10px'; // Razmak ispod slike (opciono)
            messageElement.appendChild(imgElement);
        } else {
            // Ako nije slika, prikazuje tekstualnu poruku
            messageElement.innerText = `${messageData.message}`;

        }

        // Dodaj odgovarajuƒáu klasu za po≈°iljaoca ili primaoca
        if (messageData.sender === username) {
            messageElement.classList.add('sender');
        } else {
            messageElement.classList.add('recipient');
        }

        messagesDiv.appendChild(messageElement);
    });
}



function listenForNewMessages() {
    const messagesCollection = collection(db, 'poruke');
    const q = query(messagesCollection, 
        where('sender', 'in', [username, selectedUserName]),
        where('recipient', 'in', [username, selectedUserName])
    );

    onSnapshot(q, (querySnapshot) => {
        const messagesDiv = document.getElementById('messages');
        messagesDiv.innerHTML = ''; // Oƒçisti prethodne poruke

        // Uƒçitaj poruke u niz
        const messages = [];
        querySnapshot.forEach(doc => {
            const messageData = doc.data();
            messages.push({
                ...messageData,
                id: doc.id
            });
        });

        // Sortiraj poruke po timestamp-u
        messages.sort((a, b) => a.timestamp - b.timestamp);

        // Prika≈æi sortirane poruke
        messages.forEach(messageData => {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');

            // Provjeravamo da li je poruka slika
            if (messageData.isImage) {
                const imgElement = document.createElement('img');
                imgElement.src = messageData.message; // Postavi URL slike
                imgElement.style.maxWidth = '200px'; // Maksimalna ≈°irina slike
                imgElement.style.borderRadius = '10px'; // Zaobljeni uglovi (opciono)
                imgElement.style.marginBottom = '10px'; // Razmak ispod slike (opciono)
                messageElement.appendChild(imgElement);
            } else {
                // Ako nije slika, prikazuje tekstualnu poruku
                messageElement.innerText = `${messageData.message}`;
            }

            // Dodaj odgovarajuƒáu klasu za po≈°iljaoca ili primaoca
            if (messageData.sender === username) {
                messageElement.classList.add('sender');
            } else {
                messageElement.classList.add('recipient');

                // Play the receive sound for new incoming messages only
                if (querySnapshot.docChanges().some(change => change.type === 'added' && change.doc.data().sender !== username)) {
                    receiveSound.play();
                }
            }

            messagesDiv.appendChild(messageElement);
        });

        // Automatski skroluj na dno nakon ≈°to se prika≈æu poruke
        scrollToBottom();
    });
}






// Zatvori chat kada korisnik klikne na X dugme
document.getElementById('close-chat').addEventListener('click', () => {
    closeChat(); // Zatvori chat
});

// Funkcija za zatvaranje chata
function closeChat() {
    const chatModal = document.getElementById('chat-modal');
    chatModal.style.display = 'none'; // Sakrij modalni prozor
    isChatOpen = false; // Postavi chat stanje kao zatvoreno
}

// Dodaj dogaƒëaj za povratak na listu korisnika
document.getElementById('back-to-users').addEventListener('click', () => {
    resetChat(); // Resetuj chat na listu korisnika
});

// Funkcija za resetovanje chata na poƒçetnu listu korisnika
function resetChat() {
    const usersListDiv = document.getElementById('users-list');
    const messagesDiv = document.getElementById('messages');
    const messageInputDiv = document.getElementById('message-input');
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const backButton = document.getElementById('back-to-users');
    const searchContainer = document.getElementById('search-container');
    const groupMembersDiv = document.getElementById('group-members');

    usersListDiv.style.display = 'block'; // Show user list
    messagesDiv.style.display = 'none'; // Hide chat window
    messageInputDiv.style.display = 'none'; // Hide message input
    chatHeaderTitle.innerText = 'Chat'; // Reset title to 'Chat'
    backButton.style.display = 'none'; // Hide back button

    // Show the user search again with correct display property
    searchContainer.style.display = 'flex'; // Set display to 'flex'

    // Hide and clear the 'group-members' div
    if (groupMembersDiv) {
        groupMembersDiv.innerText = '';
        groupMembersDiv.style.display = 'none';
    }

    // Clear 'groupId' from chatHeaderTitle dataset
    chatHeaderTitle.dataset.groupId = '';
}








// Funkcija za slanje poruke
const sendSound = new Audio('sounds/send-sound.mp3');
const receiveSound = new Audio('sounds/send-sound.mp3');

// Function to send a message
async function sendMessage() {
    const messageInput = document.getElementById('chat-message');
    const messageText = messageInput.value.trim();

    if (messageText) {
        const messagesCollection = collection(db, 'poruke');
        try {
            await addDoc(messagesCollection, {
                sender: username, // Ime po≈°iljaoca
                recipient: selectedUserName, // Ime primaoca
                message: messageText, // Tekst poruke
                timestamp: new Date() // Vreme slanja poruke
            });
            console.log("Poruka uspje≈°no poslana:", messageText);
            messageInput.value = ''; // Oƒçisti unos nakon slanja
            
            // Play the send sound
            sendSound.play();

            // Automatsko skrolovanje na dno nakon slanja poruke
            scrollToBottom();
        } catch (error) {
            console.error("Gre≈°ka prilikom slanja poruke:", error);
        }
    }
}



// za korisnike da se red ne remeti//
    document.getElementById("back-to-users").addEventListener("click", function() {
    document.getElementById("users-list").style.display = "flex"; // Ponovo primjeni flexbox
    document.getElementById("messages").style.display = "none"; // Sakrij poruke
    document.getElementById("message-input").style.display = "none"; // Sakrij unos poruka
    document.getElementById("back-to-users").style.display = "none"; // Sakrij dugme za povratak
});

function openChatWithUser(userId) {
    document.getElementById("users-list").style.display = "none"; // Sakrij listu korisnika
    document.getElementById("messages").style.display = "block"; // Prikazi poruke
    document.getElementById("message-input").style.display = "flex"; // Prikazi unos poruka
    document.getElementById("back-to-users").style.display = "block"; // Prikazi dugme za povratak
}




////////////////////GRUPNI CHAT//////////////////////

// Otvaranje modalnog prozora za kreiranje grupe GRUPA
document.getElementById('create-group-button').addEventListener('click', () => {
    document.getElementById('create-group-modal').style.display = 'block';
    loadFriendsList(); // Uƒçitava prijatelje sa checkbox opcijom
});

// Zatvaranje modala za kreiranje grupe
document.getElementById('cancel-create-group').addEventListener('click', () => {
    document.getElementById('create-group-modal').style.display = 'none';
});

// Uƒçitavanje liste prijatelja sa checkbox opcijom za odabir
async function loadFriendsList() {
    const friendsListDiv = document.getElementById('group-friends-list');
    friendsListDiv.innerHTML = ''; // Oƒçisti listu prije prikaza

    const uniqueContacts = Array.from(contacts).map(item => JSON.parse(item));
    uniqueContacts.forEach(friend => {
        const friendElement = document.createElement('div');
        friendElement.classList.add('friend-item');
        friendElement.style.display = 'flex';
        friendElement.style.alignItems = 'center';
        friendElement.style.marginBottom = '10px';

        // Checkbox za odabir prijatelja
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.classList.add('friend-checkbox');
        checkbox.dataset.userId = friend.userId;
        checkbox.dataset.userName = friend.userName;

        // Ime korisnika pored checkboxa
        const friendName = document.createElement('span');
        friendName.textContent = friend.userName;
        friendName.style.marginLeft = '10px';
        friendName.style.color = 'black';

        friendElement.appendChild(checkbox);
        friendElement.appendChild(friendName);
        friendsListDiv.appendChild(friendElement);
    });
}

// Kreiranje grupe i spremanje u Firestore
document.getElementById('create-group-chat-button').addEventListener('click', async () => {
    const selectedFriends = Array.from(document.querySelectorAll('.friend-checkbox:checked')).map(checkbox => ({
        userName: checkbox.dataset.userName,
        userId: checkbox.dataset.userId,
    }));
    const groupName = document.getElementById('group-name').value.trim();
    const groupImageInput = document.getElementById('group-image');
    let groupImageUrl = ''; // URL of the group image

    if (!groupName || selectedFriends.length === 0) {
        alert("Unesite naziv grupe i odaberite prijatelje koje ≈æelite dodati.");
        return;
    }

    try {
        // Check if a group image is provided; if not, use the default icon URL
        if (groupImageInput.files[0]) {
            const file = groupImageInput.files[0];
            const storageRef = ref(storage, `groupImages/${groupName}_${file.name}`);
            const snapshot = await uploadBytes(storageRef, file);
            groupImageUrl = await getDownloadURL(snapshot.ref); // URL of the uploaded image
        } else {
            groupImageUrl = ''; // Indicate no image provided, so default will be used
        }

        // Save group data, including the image URL (or leave empty for the default)
        const groupChatCollection = collection(db, 'groupChats');
        const groupDoc = await addDoc(groupChatCollection, {
            groupName,
            groupImageUrl, // Save the image URL if provided
            members: selectedFriends.concat({ userName: username, userId }), // Add current user to group
            messages: []
        });

        displayGroupChat({ groupName, groupId: groupDoc.id, groupImageUrl, members: selectedFriends });
        document.getElementById('create-group-modal').style.display = 'none';
    } catch (error) {
        console.error("Gre≈°ka prilikom kreiranja grupe:", error);
    }
});



// Prikaz grupe u listi chatova
function displayGroupChat(group) {
    const usersListDiv = document.getElementById('users-list');
    const groupElement = document.createElement('div');
    groupElement.classList.add('user-item');
    groupElement.dataset.groupId = group.groupId;

    // Dodajte sliku grupe ili default ikonu
    const imgElement = document.createElement('div');
    imgElement.style.width = '50px';
    imgElement.style.height = '50px';
    imgElement.style.borderRadius = '50%';
    imgElement.style.marginRight = '10px';
    imgElement.style.backgroundSize = 'cover';
    imgElement.style.backgroundPosition = 'center';

    // Provjera ima li grupa sliku; ako nema, prika≈æi defaultnu Google Material Icons ikonu 'group'
    if (group.groupImageUrl && group.groupImageUrl !== 'default-group-icon-url') {
        imgElement.style.backgroundImage = `url(${group.groupImageUrl})`;
    } else {
        imgElement.innerHTML = '<span class="material-icons" style="font-size: 40px; color: #5a99cd;">group</span>';
        imgElement.style.display = 'flex';
        imgElement.style.alignItems = 'center';
        imgElement.style.justifyContent = 'center';
        imgElement.style.backgroundColor = '#f0f0f0'; // Dodaj pozadinu za ikonicu
    }

    groupElement.appendChild(imgElement);

    const groupNameElement = document.createElement('span');
groupNameElement.textContent = group.groupName;
groupNameElement.style.color = 'black'; // Set the text color to black
groupNameElement.style.fontWeight = 'bold'; // Make the text bold
groupElement.appendChild(groupNameElement);


    groupElement.addEventListener('click', () => openGroupChat(group.groupId, group.groupName));
    usersListDiv.appendChild(groupElement);
}




// Pravilno otvaranje grupnog chata u modalnom prozoru
// Pravilno otvaranje grupnog chata u modalnom prozoru
async function openGroupChat(groupId, groupName) {
    // Hide search and user list
    document.getElementById('search-container').style.display = 'none';
    document.getElementById('users-list').style.display = 'none';

    // Show messages and input
    const messagesDiv = document.getElementById('messages');
    const messageInputDiv = document.getElementById('message-input');
    const backButton = document.getElementById('back-to-users');
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const groupMembersDiv = document.getElementById('group-members');

    messagesDiv.style.display = 'block';
    messageInputDiv.style.display = 'flex';
    backButton.style.display = 'block';

    // Set chat header title and groupId
    chatHeaderTitle.innerText = `Group: ${groupName}`;
    chatHeaderTitle.dataset.groupId = groupId;

    // Show the 'group-members' div
    if (groupMembersDiv) {
        groupMembersDiv.style.display = 'block'; // Ensure it's visible
    }

    // Fetch group data to get member names
    const groupChatDoc = doc(db, 'groupChats', groupId);
    const groupSnapshot = await getDoc(groupChatDoc);
    if (groupSnapshot.exists()) {
        const groupData = groupSnapshot.data();
        const members = groupData.members || [];

        // Extract member names
        const memberNames = members.map(member => member.userName).join(', ');

        // Display member names in the header
        if (groupMembersDiv) {
            groupMembersDiv.innerText = `Members: ${memberNames}`;
        }
    } else {
        console.error('Group does not exist');

        // Hide and clear the 'group-members' div if group doesn't exist
        if (groupMembersDiv) {
            groupMembersDiv.innerText = '';
            groupMembersDiv.style.display = 'none';
        }
    }



    // Load messages for this group
    loadGroupMessages(groupId);
}

///////////////grupni poziv//////

async function startGroupAudioCall(groupId) {
    const groupChatDoc = doc(db, 'groupChats', groupId);
    const groupData = (await getDoc(groupChatDoc)).data();
    const members = groupData.members || [];
    
    members.forEach(async (member) => {
        if (member.userId !== userId) { // Poziva sve osim trenutnog korisnika
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                await startAudioCall(member.userId, member.userName, stream); // Koristimo postojecu funkciju
            } catch (error) {
                console.error(`Gre≈°ka prilikom pokretanja audio poziva za ${member.userName}:`, error);
            }
        }
    });
}

async function startGroupVideoCall(groupId) {
    const groupChatDoc = doc(db, 'groupChats', groupId);
    const groupData = (await getDoc(groupChatDoc)).data();
    const members = groupData.members || [];
    
    const streams = []; // Lista za sve streams
    members.forEach(async (member) => {
        if (member.userId !== userId) { // Poziva sve osim trenutnog korisnika
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                streams.push(stream); // Dodaj stream za prikaz svih korisnika
                await startCall(member.userId, member.userName, stream);
            } catch (error) {
                console.error(`Gre≈°ka prilikom pokretanja video poziva za ${member.userName}:`, error);
            }
        }
    });

    // Nakon ≈°to se svi streamovi uƒçitaju, podijelite ekran na ƒçetiri dijela
    setupGridVideoDisplay(streams);
}


// Dogaƒëaj za dugme "Back" za povratak na listu korisnika
document.getElementById('back-to-users').addEventListener('click', () => {
    resetChat(); // Resetuj chat na listu korisnika
});


// Uƒçitavanje poruka iz grupnog chata
// Update loadGroupMessages to handle image messages
function loadGroupMessages(groupId) {
    const messagesDiv = document.getElementById('messages');
    messagesDiv.innerHTML = '';

    const groupChatDoc = doc(db, 'groupChats', groupId);
    onSnapshot(groupChatDoc, (snapshot) => {
        messagesDiv.innerHTML = '';
        const messages = snapshot.data().messages || [];

        messages.forEach((message) => {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');
            messageElement.classList.add(message.sender === username ? 'sender' : 'recipient');

            if (message.isImage) {
                const imgElement = document.createElement('img');
                imgElement.src = message.text;
                imgElement.style.maxWidth = '200px';
                imgElement.style.borderRadius = '10px';
                imgElement.style.marginBottom = '10px';
                messageElement.appendChild(imgElement);
            } else {
                messageElement.textContent = `${message.sender}: ${message.text}`;
            }
            messagesDiv.appendChild(messageElement);
        });
        scrollToBottom();
    });
}



// Slanje poruke u grupni chat
// Updated sendGroupMessage function to handle images
async function sendGroupMessage(groupId) {
    const messageInput = document.getElementById('chat-message');
    const messageText = messageInput.value.trim();

    if (messageText) {
        const groupChatDoc = doc(db, 'groupChats', groupId);
        const groupData = (await getDoc(groupChatDoc)).data();
        const messages = groupData.messages || [];

        messages.push({
            sender: username,
            text: messageText,
            timestamp: new Date(),
            isImage: false // Flag to indicate this is a text message
        });

        await updateDoc(groupChatDoc, { messages });
        messageInput.value = ''; 
        scrollToBottom();
    }
}

// Handle image upload for group chat messages
// Define a global variable for the input element
let imageInput = null;

// Event listener for the "Send Image" button in group chat
// Event listener za dugme 'send-image' koji radi za oba tipa chata
document.getElementById('send-image').addEventListener('click', () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';

    input.onchange = async (event) => {
        const file = event.target.files[0];
        if (file) {
            const isGroupChat = !!document.getElementById('chat-header-title').dataset.groupId;
            const groupId = document.getElementById('chat-header-title').dataset.groupId; // For group chat
            const recipientName = selectedUserName; // For private chat
            const recipientId = selectedUserId;

            try {
                let imageUrl;
                if (isGroupChat) {
                    // Group Chat Image Upload
                    const storageRef = ref(storage, `groupChatImages/${groupId}_${file.name}`);
                    const snapshot = await uploadBytes(storageRef, file);
                    imageUrl = await getDownloadURL(snapshot.ref);

                    const groupChatDoc = doc(db, 'groupChats', groupId);
                    const groupData = (await getDoc(groupChatDoc)).data();
                    const messages = groupData.messages || [];

                    messages.push({
                        sender: username,
                        text: imageUrl,
                        timestamp: new Date(),
                        isImage: true,
                    });

                    await updateDoc(groupChatDoc, { messages });
                } else {
                    // Private Chat Image Upload
                    if (!recipientId || !recipientName) {
                        console.error('Recipient not properly selected for private chat.');
                        return;
                    }

                    const storageRef = ref(storage, `chatImages/${username}_${recipientName}_${file.name}`);
                    const snapshot = await uploadBytes(storageRef, file);
                    imageUrl = await getDownloadURL(snapshot.ref);

                    await addDoc(collection(db, 'poruke'), {
                        sender: username,
                        recipient: recipientName,
                        message: imageUrl,
                        isImage: true,
                        timestamp: new Date(),
                    });
                }

                console.log("Image successfully sent:", imageUrl);
            } catch (error) {
                console.error("Error uploading and sending image:", error);
            }
        }
    };

    input.click(); // Open file picker
});






// Event za dugme "Po≈°alji" u grupnom chatu
document.getElementById('send-message').addEventListener('click', () => {
    const currentGroupId = document.getElementById('chat-header-title').dataset.groupId;
    if (currentGroupId) {
        sendGroupMessage(currentGroupId);
    } else {
        sendMessage(); // Slanje privatne poruke
    }
});

// Funkcija za dohvat grupa u kojima je korisnik ƒçlan
async function fetchUserGroups() {
    const groupChatCollection = collection(db, 'groupChats');
    const q = query(groupChatCollection, where('members', 'array-contains', { userName: username, userId: userId }));

    const querySnapshot = await getDocs(q);

    querySnapshot.forEach(doc => {
        const groupData = doc.data();
        allUsers.push({
            userName: groupData.groupName, // Koristimo naziv grupe kao ime
            userId: doc.id, // ID grupe
            profilePictureUrl: groupData.groupImageUrl || '', // Slika grupe ili prazno
            isGroup: true // Oznaƒçavamo da je ovo grupa
        });

        // Prikaz u listi kontakata
        displayGroupChat({
            groupName: groupData.groupName,
            groupId: doc.id,
            groupImageUrl: groupData.groupImageUrl,
            members: groupData.members,
        });
    });
}






//////////////////////////////////////////////VIDEOPOZIV///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Configuration for WebRTC
const configuration = {
    iceServers: [
        {
            urls: 'stun:stun.l.google.com:19302' // Google STUN server
        }
    ]
};

// When the user clicks the call button
document.getElementById('start-call').addEventListener('click', async () => {
    if (!selectedUserId || !selectedUserName) {
        console.error('selectedUserId ili selectedUserName nisu postavljeni');
        return;
    }
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        await startCall(selectedUserId, selectedUserName, stream);
    } catch (error) {
        console.error('Gre≈°ka prilikom pokretanja poziva:', error);
    }
});


// Function to start the call
async function startCall(userId, userName, stream) {
    const callRef = collection(db, 'calls');
    const callDoc = await addDoc(callRef, {
        caller: username,
        recipientId: userId,
        recipientName: userName,
        answered: false,
        ongoing: true,
        timestamp: new Date(),
        offer: null,
        answer: null
    });

    showCallingNotification(userName);
    console.log(`Calling user ${userName}.`);

    // Add local video
    addLocalVideo(stream);

    const peerConnection = new RTCPeerConnection(configuration);

    // Add local tracks to peer connection
    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

    // Create remote stream
    const remoteStream = new MediaStream();
    // Add remote stream to video element
    addRemoteVideo(remoteStream);

    // Handle ICE candidates from the caller
    const callerCandidatesCollection = collection(callDoc, 'callerCandidates');
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            addDoc(callerCandidatesCollection, event.candidate.toJSON());
        }
    };

    // Handle remote tracks
    peerConnection.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
            remoteStream.addTrack(track);
        });
    };

    // Create offer and set local description
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    // Update the call document with the offer
    await updateDoc(callDoc, { offer: { type: offer.type, sdp: offer.sdp } });

    // Listen for answer
    onSnapshot(callDoc, (docSnapshot) => {
        const data = docSnapshot.data();
        if (data.answer && !peerConnection.currentRemoteDescription) {
            const answerDescription = new RTCSessionDescription(data.answer);
            peerConnection.setRemoteDescription(answerDescription);
            // Show "End Call" button for caller
            showEndCallButton(callDoc.id, peerConnection);
        }
    });

    // Listen for callee's ICE candidates
    const calleeCandidatesCollection = collection(callDoc, 'calleeCandidates');
    onSnapshot(calleeCandidatesCollection, snapshot => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const candidate = new RTCIceCandidate(change.doc.data());
                peerConnection.addIceCandidate(candidate).catch(e => {
                    console.error('Error adding received ICE candidate', e);
                });
            }
        });
    });

    console.log("Call established at caller.");
}

// Function to accept the call
async function acceptCall(callId, stream) {
    const callRef = doc(db, 'calls', callId);
    const callData = (await getDoc(callRef)).data();
    await updateDoc(callRef, { answered: true });

    const peerConnection = new RTCPeerConnection(configuration);

    // Dodajemo samo audio za audio poziv
    if (callData.isAudioOnly) {
        stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } else {
        stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    }

    // Dodaj lokalne trake u peer connection
    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

    // Dodavanje lokalnog videa (samo za video poziv)
    if (!callData.isAudioOnly) {
        addLocalVideo(stream);
    }

    // Kreiranje remote streama
    const remoteStream = new MediaStream();
    addRemoteVideo(remoteStream);

    // Podno≈°enje ICE kandidata od primatelja
    const calleeCandidatesCollection = collection(callRef, 'calleeCandidates');
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            addDoc(calleeCandidatesCollection, event.candidate.toJSON());
        }
    };

    // Rukovanje remote trakama
    peerConnection.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
            remoteStream.addTrack(track);
        });
    };

    // Postavljanje remote opisa i kreiranje odgovora
    await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);

    // A≈æuriranje dokumenta poziva sa odgovorom
    await updateDoc(callRef, { answer: { type: answer.type, sdp: answer.sdp } });
    showEndCallButton(callId, peerConnection);

    // Slu≈°anje ICE kandidata pozivatelja
    const callerCandidatesCollection = collection(callRef, 'callerCandidates');
    onSnapshot(callerCandidatesCollection, snapshot => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const candidate = new RTCIceCandidate(change.doc.data());
                peerConnection.addIceCandidate(candidate).catch(e => {
                    console.error('Gre≈°ka prilikom dodavanja primljenog ICE kandidata', e);
                });
            }
        });
    });

    console.log("Poziv uspostavljen kod primatelja.");
}


// Function to add local video
function addLocalVideo(stream) {
    let localVideo = document.getElementById('localVideo');
    if (!localVideo) {
        localVideo = document.createElement('video');
        localVideo.id = 'localVideo';
        localVideo.style.position = 'absolute';
        localVideo.style.bottom = '10px';
        localVideo.style.right = '10px';
        localVideo.style.width = '100px'; // Smaller local video
        localVideo.style.border = '2px solid yellow';
        localVideo.style.zIndex = '10000'; // Higher z-index to appear over remote video
        localVideo.autoplay = true;
        localVideo.muted = true;
        localVideo.playsInline = true;
        // Dodajte transformaciju za zrcaljenje
        localVideo.style.transform = 'scaleX(-1)';
        document.body.appendChild(localVideo);
    }
    localVideo.srcObject = stream;
}


// Function to add remote video
function addRemoteVideo(stream) {
    let remoteVideo = document.getElementById('remoteVideo');
    let remoteVideoBlur = document.getElementById('remoteVideoBlur');

    // Create blurred background video if it doesn't exist
    if (!remoteVideoBlur) {
        remoteVideoBlur = document.createElement('video');
        remoteVideoBlur.id = 'remoteVideoBlur';
        remoteVideoBlur.style.position = 'fixed';
        remoteVideoBlur.style.top = '0';
        remoteVideoBlur.style.left = '0';
        remoteVideoBlur.style.width = '100vw'; // Full viewport width
        remoteVideoBlur.style.height = '100vh'; // Full viewport height
        remoteVideoBlur.style.filter = 'blur(20px)'; // Apply blur effect
        remoteVideoBlur.style.transform = 'scale(1.1)'; // Slightly scale up the blurred background
        remoteVideoBlur.style.zIndex = '9998'; // Place it behind the remote video
        remoteVideoBlur.autoplay = true;
        remoteVideoBlur.playsInline = true;
        remoteVideoBlur.muted = true; // No sound for the blurred background
        document.body.appendChild(remoteVideoBlur);
    }
    remoteVideoBlur.srcObject = stream; // Set the same stream for the blurred background

    // Create main remote video
    if (!remoteVideo) {
        remoteVideo = document.createElement('video');
        remoteVideo.id = 'remoteVideo';
        remoteVideo.style.position = 'fixed';
        remoteVideo.style.top = '0';
        remoteVideo.style.left = '0';
        remoteVideo.style.width = '100vw'; // Full viewport width
        remoteVideo.style.height = '100vh'; // Full viewport height
        remoteVideo.style.objectFit = 'cover'; // Stretch the video to cover the entire frame
        remoteVideo.style.border = '2px solid red';
        remoteVideo.style.zIndex = '9999'; // Keep it above the blurred background
        remoteVideo.autoplay = true;
        remoteVideo.playsInline = true;
        document.body.appendChild(remoteVideo);
    }
    remoteVideo.srcObject = stream;
}

// Show notification that user is calling (caller side)
function showCallingNotification(recipientName) {
    const callingOverlay = document.createElement('div');
    callingOverlay.classList.add('calling-overlay');
    callingOverlay.innerHTML = 
        `<div class="calling-content">
            <p>Calling ${recipientName}...</p>
        </div>`;
    
    callingOverlay.style.position = 'fixed';
    callingOverlay.style.top = '0';
    callingOverlay.style.left = '0';
    callingOverlay.style.width = '100vw';
    callingOverlay.style.height = '100vh';
    callingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Transparent dark background
    callingOverlay.style.color = 'white';
    callingOverlay.style.display = 'flex';
    callingOverlay.style.flexDirection = 'column';
    callingOverlay.style.justifyContent = 'center';
    callingOverlay.style.alignItems = 'center';
    callingOverlay.style.zIndex = '1000';
    callingOverlay.style.fontSize = '24px';

    document.body.appendChild(callingOverlay);
}

// Function to show incoming call notification (callee side)
function showIncomingCallNotification(callerName, callId) {
    const incomingCallOverlay = document.createElement('div');
    incomingCallOverlay.classList.add('incoming-call-overlay');
    incomingCallOverlay.innerHTML = 
        `<div class="incoming-call-content">
            <p>${callerName} is calling you...</p>
            <div class="incoming-call-buttons-container" style="background-color: white; padding: 10px; border-radius: 8px; margin-top: 10px;">
                <button id="answer-call-${callId}" style="background-color: green; color: white; padding: 10px 20px; margin-right: 10px; border-radius: 5px;">Accept</button>
                <button id="decline-call-${callId}" style="background-color: red; color: white; padding: 10px 20px; border-radius: 5px;">Decline</button>
            </div>
        </div>`;
    
    incomingCallOverlay.style.position = 'fixed';
    incomingCallOverlay.style.top = '0';
    incomingCallOverlay.style.left = '0';
    incomingCallOverlay.style.width = '100vw';
    incomingCallOverlay.style.height = '100vh';
    incomingCallOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Transparent dark background
    incomingCallOverlay.style.color = 'white';
    incomingCallOverlay.style.display = 'flex';
    incomingCallOverlay.style.flexDirection = 'column';
    incomingCallOverlay.style.justifyContent = 'center';
    incomingCallOverlay.style.alignItems = 'center';
    incomingCallOverlay.style.zIndex = '1000';
    incomingCallOverlay.style.fontSize = '24px';

    document.body.appendChild(incomingCallOverlay);

    // Event for accepting the call
    document.getElementById(`answer-call-${callId}`).addEventListener('click', async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        await acceptCall(callId, stream);
        document.body.removeChild(incomingCallOverlay); // Remove overlay
    });

    // Event for declining the call
    document.getElementById(`decline-call-${callId}`).addEventListener('click', () => {
        document.body.removeChild(incomingCallOverlay); // Remove overlay
        // Optionally, update call document to indicate call was declined
    });
}


// Function to show "End Call" button
// Funkcija za prikaz "End Call" dugmeta kao crvenog kruga sa bijelim "X"
// Function to show "End Call" button
function showEndCallButton(callId, peerConnection) {
    const endCallButton = document.createElement('div');
    endCallButton.id = 'end-call';
    endCallButton.style.position = 'fixed';
    endCallButton.style.bottom = '20px';
    endCallButton.style.left = '50%';
    endCallButton.style.transform = 'translateX(-50%)';
    endCallButton.style.width = '60px';
    endCallButton.style.height = '60px';
    endCallButton.style.backgroundColor = 'red';
    endCallButton.style.borderRadius = '50%';
    endCallButton.style.display = 'flex';
    endCallButton.style.justifyContent = 'center';
    endCallButton.style.alignItems = 'center';
    endCallButton.style.zIndex = '10001';
    endCallButton.style.cursor = 'pointer';

    // Add white "X" inside red circle
    const xIcon = document.createElement('div');
    xIcon.style.color = 'white';
    xIcon.style.fontSize = '24px';
    xIcon.style.fontWeight = 'bold';
    xIcon.textContent = 'X';

    endCallButton.appendChild(xIcon);
    document.body.appendChild(endCallButton);

    endCallButton.addEventListener('click', async () => {
        peerConnection.close();  // Close the peer connection
        await updateDoc(doc(db, 'calls', callId), { ongoing: false });  // Update call status in Firestore
        removeCallInterface();  // Remove the call interface elements
        console.log("Call ended.");
    });
}

// Function to remove call-related elements from the page
function removeCallInterface() {
    // Stop and remove local video
    const localVideo = document.getElementById('localVideo');
    if (localVideo) {
        const localStream = localVideo.srcObject;
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());  // Stop all tracks
        }
        document.body.removeChild(localVideo);  // Remove video element from DOM
    }

    // Stop and remove remote video and blurred background
    const remoteVideo = document.getElementById('remoteVideo');
    const remoteVideoBlur = document.getElementById('remoteVideoBlur');
    if (remoteVideo) {
        const remoteStream = remoteVideo.srcObject;
        if (remoteStream) {
            remoteStream.getTracks().forEach(track => track.stop());  // Stop all tracks
        }
        document.body.removeChild(remoteVideo);  // Remove video element from DOM
    }
    if (remoteVideoBlur) {
        document.body.removeChild(remoteVideoBlur);  // Remove blurred background
    }

    // Remove overlays (e.g., calling and incoming call notifications)
    const callingOverlay = document.querySelector('.calling-overlay');
    const incomingCallOverlay = document.querySelector('.incoming-call-overlay');
    if (callingOverlay) document.body.removeChild(callingOverlay);
    if (incomingCallOverlay) document.body.removeChild(incomingCallOverlay);

    // Remove end call button
    const endCallButton = document.getElementById('end-call');
    if (endCallButton) document.body.removeChild(endCallButton);

    console.log("All call-related elements have been removed from the page.");
}



// Function to set up listening for incoming calls
function setupIncomingCallListener() {
    const callRef = collection(db, 'calls');
    onSnapshot(callRef, (snapshot) => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const doc = change.doc;
                const data = doc.data();
                if (!data.answered && data.recipientId === userId) {
                    console.log('Dolazni poziv od:', data.caller);
                    showIncomingCallNotification(data.caller, doc.id);
                }
            }
        });
    });
}



// Initialize listening for incoming calls
setupIncomingCallListener();






document.addEventListener('DOMContentLoaded', () => {
    const prijavljeniKorisnik = localStorage.getItem('loggedInUser');
    if (prijavljeniKorisnik) {
        document.getElementById('ime').innerText = prijavljeniKorisnik; // Prika≈æi ime prijavljenog korisnika
    }
});



async function updateTotalCoinsSpent() {
    const userCollection = collection(db, 'network');
    const querySnapshot = await getDocs(userCollection);
    let totalCoinsSpent = 0;

    querySnapshot.forEach(doc => {
        const userData = doc.data();
        const userCurrentPrice = userData.currentPrice || 0;
        totalCoinsSpent += userCurrentPrice;
    });

    // A≈æurirajte prikaz na stranici
    document.getElementById('coins-spent').innerText = totalCoinsSpent.toFixed(2);
}

////////////////////////////////////////////////////////////////////////////////////////////////AUDIO POZIV/////////////////////////////////////////////////////////////////////////

// When the user clicks the audio call button
// Kada korisnik klikne dugme za audio poziv
document.getElementById('start-audio-call').addEventListener('click', async () => {
    if (!selectedUserId || !selectedUserName) {
        console.error('selectedUserId ili selectedUserName nisu postavljeni');
        return;
    }
    try {
        // Tra≈æimo samo mikrofon za audio poziv
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        await startAudioCall(selectedUserId, selectedUserName, stream);
    } catch (error) {
        console.error('Gre≈°ka prilikom pokretanja audio poziva:', error);
    }
});

// Funkcija za pokretanje audio poziva
async function startAudioCall(userId, userName, stream) {
    const callRef = collection(db, 'calls');
    const callDoc = await addDoc(callRef, {
        caller: username,
        recipientId: userId,
        recipientName: userName,
        answered: false,
        ongoing: true,
        timestamp: new Date(),
        offer: null,
        answer: null,
        isAudioOnly: true // Oznaka da je poziv samo audio
    });

    showCallingNotification(userName);
    console.log(`Calling user ${userName} (audio only).`);

    const peerConnection = new RTCPeerConnection(configuration);

    // Dodajemo samo audio trake u peer konekciju
    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

    // Kreiranje remote audio streama
    const remoteAudio = new Audio();
    remoteAudio.autoplay = true;

    // Rukovanje ICE kandidatima od pozivatelja
    const callerCandidatesCollection = collection(callDoc, 'callerCandidates');
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            addDoc(callerCandidatesCollection, event.candidate.toJSON());
        }
    };

    // Rukovanje remote audio trakama
    peerConnection.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
            remoteAudio.srcObject = event.streams[0];
        });
    };

    // Kreiranje ponude i postavljanje lokalnog opisa
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    // A≈æuriranje dokumenta poziva s ponudom
    await updateDoc(callDoc, { offer: { type: offer.type, sdp: offer.sdp } });

    // Slu≈°anje odgovora
    onSnapshot(callDoc, (docSnapshot) => {
        const data = docSnapshot.data();
        if (data.answer && !peerConnection.currentRemoteDescription) {
            const answerDescription = new RTCSessionDescription(data.answer);
            peerConnection.setRemoteDescription(answerDescription);
            showEndCallButton(callDoc.id, peerConnection);
        }
    });

    // Slu≈°anje ICE kandidata primatelja
    const calleeCandidatesCollection = collection(callDoc, 'calleeCandidates');
    onSnapshot(calleeCandidatesCollection, snapshot => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const candidate = new RTCIceCandidate(change.doc.data());
                peerConnection.addIceCandidate(candidate).catch(e => {
                    console.error('Gre≈°ka prilikom dodavanja primljenog ICE kandidata', e);
                });
            }
        });
    });

    console.log("Audio poziv uspostavljen.");
}




///////////////////////////////////////////////////////////////////////////////////IGRA///////////////////////////////////////////////////////////////////////

// Variables for the game
let gameId = null;
let playerSymbol = null;

// Function to send a game request
document.getElementById('start-game').addEventListener('click', async () => {
    if (!selectedUserId || !selectedUserName) {
        alert("No user selected for the game.");
        return;
    }
    try {
        // First, create the game document
        const gameDocRef = await addDoc(collection(db, 'games'), {
            players: [userId, selectedUserId],
            playerSymbols: {
                [userId]: 'X',
                [selectedUserId]: 'O'
            },
            boardState: Array(9).fill(null),
            currentPlayer: userId, // The requester starts
            gameStatus: 'in_progress',
            winner: null,
            timestamp: new Date()
        });
        gameId = gameDocRef.id;
        playerSymbol = 'X'; // The requester is 'X'

        // Then, send the game request, including the gameId
        const gameRequestRef = await addDoc(collection(db, 'gameRequests'), {
            requester: username,
            requesterId: userId,
            recipientId: selectedUserId,
            recipientName: selectedUserName,
            accepted: false,
            timestamp: new Date(),
            gameId: gameId // Include the gameId
        });
        console.log("Game request sent:", gameRequestRef.id);
        // Add listener for game acceptance
        listenForGameAcceptance(gameRequestRef.id);
        alert(`Waiting for ${selectedUserName} to accept your game request.`);
        // Start listening to the game document
        startTicTacToeGame(gameId);
    } catch (error) {
        console.error("Error sending game request:", error);
    }
});

// Function to listen for game acceptance
function listenForGameAcceptance(gameRequestId) {
    const gameRequestDocRef = doc(db, 'gameRequests', gameRequestId);
    onSnapshot(gameRequestDocRef, async (docSnapshot) => {
        const data = docSnapshot.data();
        if (data.accepted) {
            console.log("Game request accepted.");
            // The game has already been created, gameId is already set
            // We can start the game
            // Ensure that gameId is set
            if (!gameId) {
                gameId = data.gameId;
                playerSymbol = 'X'; // The requester is 'X'
                startTicTacToeGame(gameId);
            }
        }
    });
}

// Function to set up game request listener for incoming requests
function setupGameRequestListener() {
    const gameRequestRef = collection(db, 'gameRequests');
    onSnapshot(gameRequestRef, (snapshot) => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const data = change.doc.data();
                if (!data.accepted && data.recipientId === userId) {
                    showIncomingGameNotification(data.requester, data.requesterId, change.doc.id);
                }
            }
        });
    });
}

// Function to show incoming game notification
function showIncomingGameNotification(requesterName, requesterId, gameRequestId) {
    const notification = document.createElement('div');
    notification.classList.add('incoming-game-notification');
    notification.innerHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background-color: white; padding: 20px; border-radius: 10px; z-index: 1000;">
<p style="color: black;">${requesterName} invites you to play Tic Tac Toe. Do you accept?</p>

            <button id="accept-game" style="background-color: green; color: white; padding: 10px 20px; margin-right: 10px;">Accept</button>
            <button id="decline-game" style="background-color: red; color: white; padding: 10px 20px;">Decline</button>
        </div>
    `;
    document.body.appendChild(notification);

    // Accept the game
    document.getElementById('accept-game').addEventListener('click', async () => {
        // Update the game request to accepted
        const gameRequestDocRef = doc(db, 'gameRequests', gameRequestId);
        await updateDoc(gameRequestDocRef, { accepted: true });
        // Get the gameId from the game request document
        const gameRequestDoc = await getDoc(gameRequestDocRef);
        const gameRequestData = gameRequestDoc.data();
        gameId = gameRequestData.gameId;
        playerSymbol = 'O'; // The recipient is 'O'
        document.body.removeChild(notification);
        // Start the game
        startTicTacToeGame(gameId);
    });

    // Decline the game
    document.getElementById('decline-game').addEventListener('click', () => {
        document.body.removeChild(notification);
    });
}

// Function to start the game
function startTicTacToeGame(gameId) {
    const boardDiv = document.getElementById('tic-tac-toe-board');
    const cells = document.querySelectorAll('.cell');

    boardDiv.style.display = 'block';

    const gameDocRef = doc(db, 'games', gameId);

    // Set up onSnapshot listener on the game document
    onSnapshot(gameDocRef, (docSnapshot) => {
        const data = docSnapshot.data();
        if (!data) return;

        const boardState = data.boardState;
        const currentPlayerId = data.currentPlayer;
        const gameStatus = data.gameStatus;
        const winnerId = data.winner;

        // Update the board display
        cells.forEach((cell, index) => {
            cell.textContent = boardState[index];
        });

        if (gameStatus === 'finished') {
    if (winnerId === 'draw') {
        alert('Nerije≈°eno!');
    } else {
        if (winnerId === userId) {
            alert('You won 100Œ¥ Delta Coin!');
            // Prika≈æi konfete
            showConfetti();
        } else {
            alert('You lost!');
        }
        // A≈æuriraj currentPrice za pobjednika
        updateCurrentPriceForWinner(winnerId);
    }
    boardDiv.style.display = 'none';
    resetBoard();
        } else {
            if (currentPlayerId === userId) {
                console.log('Your turn.');
            } else {
                console.log('Opponent\'s turn.');
            }
        }
    });


    // Add click events to each cell only once
    cells.forEach(cell => {
        cell.onclick = async function() {
            const index = cell.getAttribute('data-index');

            // Fetch the latest game data
            const gameDoc = await getDoc(gameDocRef);
            const data = gameDoc.data();

            // Create a copy of the boardState to avoid mutating the original
            const boardState = [...data.boardState];
            const currentPlayerId = data.currentPlayer;
            const playerSymbols = data.playerSymbols;

            if (boardState[index] || data.gameStatus !== 'in_progress') {
                // The cell is already occupied or the game is over
                alert('Cell is already occupied or the game is over.');
                return;
            }

            if (currentPlayerId !== userId) {
                // Not your turn
                alert('Not your turn.');
                return;
            }

            // Make the move
            boardState[index] = playerSymbols[userId];

            // Check if we have a winner or a draw
            const winner = checkGameWinner(boardState);

            let newGameStatus = 'in_progress';
            let newWinnerId = null;
            let nextPlayerId = data.players.find(id => id !== userId); // The other player

            if (winner) {
                newGameStatus = 'finished';
                if (winner === 'draw') {
                    newWinnerId = 'draw';
                    nextPlayerId = null;
                } else {
                    newWinnerId = userId; // The current player is the winner
                    nextPlayerId = null;
                }
            }

            // Update the game document
            await updateDoc(gameDocRef, {
                boardState: boardState,
                currentPlayer: nextPlayerId,
                gameStatus: newGameStatus,
                winner: newWinnerId
            });
        };
    });

    // Button to close the game
    document.getElementById('close-game').addEventListener('click', () => {
        boardDiv.style.display = 'none';
        resetBoard();
    });
}

// Function to check for a winner or a draw
function checkGameWinner(boardState) {
    const winningCombinations = [
        [0,1,2], [3,4,5], [6,7,8], // Rows
        [0,3,6], [1,4,7], [2,5,8], // Columns
        [0,4,8], [2,4,6]           // Diagonals
    ];

    for (let combo of winningCombinations) {
        const [a, b, c] = combo;
        if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
            return true; // We have a winner
        }
    }

    if (boardState.every(cell => cell !== null)) {
        return 'draw'; // Draw
    }

    return null; // The game is not over
}

// Function to reset the board
function resetBoard() {
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        cell.textContent = '';
    });
    gameId = null;
    playerSymbol = null;
}

// Set up listener for incoming game requests
setupGameRequestListener();


async function updateCurrentPriceForWinner(winnerUserId) {
    const userDocRef = doc(db, 'network', winnerUserId);
    try {
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
            const userData = userDoc.data();
            let currentPrice = userData.currentPrice || 0;
            currentPrice += 100; // Add 100 to the currentPrice
            await updateDoc(userDocRef, {
                currentPrice: currentPrice
            });
            console.log('Updated currentPrice for winner:', winnerUserId);

            // If the winner is the current user, update the displayed amount
            if (winnerUserId === userId) {
                document.getElementById('amount').innerText = currentPrice.toFixed(2);
            }
        } else {
            console.error('User document not found for winner:', winnerUserId);
        }
    } catch (error) {
        console.error('Error updating currentPrice for winner:', error);
    }
}


function showConfetti() {
    var duration = 5 * 1000;
    var animationEnd = Date.now() + duration;
    var defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1000 };

    function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    var interval = setInterval(function() {
        var timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
            return clearInterval(interval);
        }

        var particleCount = 50 * (timeLeft / duration);
        // Pokreni konfete iz nasumiƒçnih pozicija
        confetti(Object.assign({}, defaults, { 
            particleCount, 
            origin: { x: randomInRange(0, 1), y: Math.random() - 0.2 } 
        }));
    }, 250);
}







//////////////////////////////////////IGREEEEEEEEEEEEEEEEEEEE///////////////////////////

document.addEventListener('DOMContentLoaded', () => {
    // Pronaƒëi sve elemente sa ID-jem "games-link"
    const gamesLinks = document.querySelectorAll('#games-link');

    // Dodaj dogaƒëaj za svaki od njih
    gamesLinks.forEach((link) => {
        link.addEventListener('click', () => {
            const gamesModal = document.createElement('div');
            gamesModal.id = 'games-modal';
            gamesModal.style = `
                position: fixed; 
                top: 50%; 
                left: 50%; 
                transform: translate(-50%, -50%); 
                background-color: white; 
                padding: 20px; 
                border-radius: 10px; 
                z-index: 1000; 
                display: flex; 
                flex-direction: column;
                gap: 10px;
                align-items: center;
                width: 80%;
                max-width: 500px;
            `;

            gamesModal.innerHTML = `
    <h3 style="color: black;">Games</h3>
    <button id="snake-game" style="padding: 10px 20px; background-color: #ddd; border: none; cursor: pointer;">
        <span class="material-icons">pets</span> Snake
    </button>
    <button id="flappy-game" style="padding: 10px 20px; background-color: #ddd; border: none; cursor: pointer;">
        <span class="material-icons">flight</span> Flappy Bird
    </button>
    <button id="close-games-modal" style="margin-top: 20px; padding: 10px 20px; background-color: red; color: white; border: none; cursor: pointer;">Close</button>
`;

            document.body.appendChild(gamesModal);

            // Zatvaranje modala
            document.getElementById('close-games-modal').addEventListener('click', () => {
                document.body.removeChild(gamesModal);
            });

            // Otvaranje Snake igre
            document.getElementById('snake-game').addEventListener('click', () => {
                startSnakeGame();
                document.body.removeChild(gamesModal);
            });
            document.getElementById('flappy-game').addEventListener('click', () => {
    startFlappyBird();
    document.body.removeChild(gamesModal);
});
        });
    });
});



function startSnakeGame() {
    // Dodaj zamagljenje pozadine
    const overlay = document.createElement('div');
    overlay.id = 'overlay';
    overlay.style = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        z-index: 999;
    `;
    document.body.appendChild(overlay);

    const gameWrapper = document.createElement('div');
    gameWrapper.id = 'game-wrapper';
    gameWrapper.style = `
        position: fixed; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        text-align: center;
        z-index: 1000;
    `;

    const scoreContainer = document.createElement('div');
    scoreContainer.id = 'score-container';
    scoreContainer.style = `
        color: white; 
        margin-bottom: 10px; 
        font-family: Arial, sans-serif;
    `;
    scoreContainer.innerHTML = `
        <h2 style="margin: 0;">Score: <span id="score">0</span></h2>
        <h3 style="margin: 0;">Highscore: <span id="highscore">0</span></h3>
    `;
    gameWrapper.appendChild(scoreContainer);

    const snakeGameContainer = document.createElement('div');
    snakeGameContainer.id = 'snake-game-container';
    snakeGameContainer.style = `
        position: relative; 
        background-color: black; 
        width: 300px; /* Smanjena ≈°irina */
        height: 300px; /* Smanjena visina */
        border: 2px solid white; 
        overflow: hidden;
    `;
    gameWrapper.appendChild(snakeGameContainer);

    document.body.appendChild(gameWrapper);

    const gridSize = 300; // Veliƒçina tabele
    const cellSize = 15; // Veliƒçina svake ƒáelije

    let snake = [{ x: 150, y: 150 }];
    let food = generateFood();
    let direction = { x: 0, y: 0 };
    let nextDirection = { x: 0, y: 0 };
    let score = 0;
    let highscore = localStorage.getItem('snakeHighscore') || 0;
    let lastTimestamp = 0;

    document.getElementById('highscore').textContent = highscore;

    function generateFood() {
        return {
            x: Math.floor(Math.random() * (gridSize / cellSize)) * cellSize,
            y: Math.floor(Math.random() * (gridSize / cellSize)) * cellSize,
        };
    }

    function drawGame() {
        snakeGameContainer.innerHTML = '';

        // Nacrtaj zmiju
        snake.forEach((segment, index) => {
            const segmentDiv = document.createElement('div');
            const isHead = index === 0;
            segmentDiv.style = `
                position: absolute; 
                width: ${cellSize}px; 
                height: ${cellSize}px; 
                left: ${segment.x}px; 
                top: ${segment.y}px;
                background-color: ${isHead ? 'yellow' : 'green'};
                border-radius: ${isHead ? '50%' : '30%'};
            `;
            snakeGameContainer.appendChild(segmentDiv);
        });

        // Nacrtaj hranu
        const foodDiv = document.createElement('div');
        foodDiv.style = `
            position: absolute; 
            width: ${cellSize - 5}px; 
            height: ${cellSize - 5}px; 
            background-color: red; 
            left: ${food.x + 2.5}px; 
            top: ${food.y + 2.5}px; 
            border-radius: 50%;
        `;
        snakeGameContainer.appendChild(foodDiv);
    }

    async function updateSnake(timestamp) {
    if (!lastTimestamp) {
        lastTimestamp = timestamp;
        requestAnimationFrame(updateSnake);
        return;
    }

    const deltaTime = timestamp - lastTimestamp;

    if (deltaTime > 150) {
        lastTimestamp = timestamp;

        // A≈æuriraj pravac
        direction = nextDirection;

        // Glava zmije
        const head = {
            x: (snake[0].x + direction.x + gridSize) % gridSize,
            y: (snake[0].y + direction.y + gridSize) % gridSize,
        };

        // Sudar sa telom
        if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('snakeHighscore', highscore);

                // A≈æuriraj trenutnu cenu korisnika u Firestore
                await updateCurrentPriceForHighscore(userId, score);

                // Pokreni konfete animaciju
                confetti({
                    particleCount: 150,
                    spread: 70,
                    origin: { y: 0.6 }
                });
            }
            alert('Game Over!');
            document.body.removeChild(gameWrapper);
            document.body.removeChild(overlay); // Ukloni zamagljenje
            return;
        }

        snake.unshift(head);

        // Proveri da li zmija jede hranu
        if (head.x === food.x && head.y === food.y) {
            score++;
            document.getElementById('score').textContent = score;
            food = generateFood();
        } else {
            snake.pop();
        }

        drawGame();
    }

    requestAnimationFrame(updateSnake);
}


    function changeDirection(event) {
        const key = event.key;
        if (key === 'ArrowUp' && direction.y === 0) nextDirection = { x: 0, y: -cellSize };
        if (key === 'ArrowDown' && direction.y === 0) nextDirection = { x: 0, y: cellSize };
        if (key === 'ArrowLeft' && direction.x === 0) nextDirection = { x: -cellSize, y: 0 };
        if (key === 'ArrowRight' && direction.x === 0) nextDirection = { x: cellSize, y: 0 };
    }

    function handleTouchStart(event) {
        event.preventDefault();
        const touch = event.touches[0];
        this.startX = touch.clientX;
        this.startY = touch.clientY;
    }

    function handleTouchMove(event) {
        event.preventDefault();
        if (!this.startX || !this.startY) return;

        const touch = event.touches[0];
        const dx = touch.clientX - this.startX;
        const dy = touch.clientY - this.startY;

        if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > 0 && direction.x === 0) nextDirection = { x: cellSize, y: 0 };
            if (dx < 0 && direction.x === 0) nextDirection = { x: -cellSize, y: 0 };
        } else {
            if (dy > 0 && direction.y === 0) nextDirection = { x: 0, y: cellSize };
            if (dy < 0 && direction.y === 0) nextDirection = { x: 0, y: -cellSize };
        }

        this.startX = null;
        this.startY = null;
    }

    drawGame();
    requestAnimationFrame(updateSnake);

    window.addEventListener('keydown', changeDirection);
    snakeGameContainer.addEventListener('touchstart', handleTouchStart, false);
    snakeGameContainer.addEventListener('touchmove', handleTouchMove, false);
}

window.addEventListener('keydown', (event) => {
    if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
        event.preventDefault();
    }
});


async function updateCurrentPriceForHighscore(userId, amount) {
    const userDocRef = doc(db, 'network', userId);
    try {
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
            const userData = userDoc.data();
            let currentPrice = userData.currentPrice || 0;
            currentPrice += amount; // Dodaj iznos u trenutnu cenu
            await updateDoc(userDocRef, {
                currentPrice: currentPrice
            });
            console.log(`Updated currentPrice for user ${userId} by ${amount}. New currentPrice: ${currentPrice}`);

            // A≈æuriraj prikazani iznos ako je trenutni korisnik
            if (userId === loggedInUserId) {
                document.getElementById('amount').innerText = currentPrice.toFixed(2);
            }
        } else {
            console.error('User document not found:', userId);
        }
    } catch (error) {
        console.error('Error updating currentPrice:', error);
    }
}

/////////////////////////////FLAPPY BIRD////////////////////////////////



function startFlappyBird() {
    // Dodaj zamagljenje pozadine
    const overlay = document.createElement('div');
    overlay.id = 'overlay';
    overlay.style = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(5px);
        z-index: 999;
    `;
    document.body.appendChild(overlay);

    const gameWrapper = document.createElement('div');
    gameWrapper.id = 'game-wrapper';
    gameWrapper.style = `
        position: fixed; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        text-align: center;
        z-index: 1000;
    `;

    const scoreContainer = document.createElement('div');
    scoreContainer.id = 'score-container';
    scoreContainer.style = `
        color: white; 
        margin-bottom: 10px; 
        font-family: Arial, sans-serif;
    `;
    scoreContainer.innerHTML = `
        <h2 style="margin: 0;">Score: <span id="flappy-score">0</span></h2>
        <h3 style="margin: 0;">Highscore: <span id="flappy-highscore">0</span></h3>
    `;
    gameWrapper.appendChild(scoreContainer);

    const flappyGameContainer = document.createElement('canvas');
    flappyGameContainer.id = 'flappy-game-container';
    flappyGameContainer.width = 700; // Poveƒáana ≈°irina
    flappyGameContainer.height = 900; // Poveƒáana visina
    flappyGameContainer.style = `
        background-color: lightblue; 
        border: 2px solid white; 
        display: block;
        margin: auto;
    `;

// Poveƒáaj cijeli okvir za mobilne ureƒëaje
if (window.innerWidth <= 768) { // Provjera za mobilne ureƒëaje
    gameWrapper.style.width = '90vw'; // Postavlja ≈°irinu okvira na 90% ekrana
    gameWrapper.style.height = '90vh'; // Postavlja visinu okvira na 90% ekrana
}

    
    gameWrapper.appendChild(flappyGameContainer);

    document.body.appendChild(gameWrapper);

    const ctx = flappyGameContainer.getContext('2d');
    let bird = { x: 50, y: 300, width: 40, height: 40, velocity: 0 }; // Dimenzije ptice
    let gravity = 0.5;
    let score = 0;
    let highscore = localStorage.getItem('flappyHighscore') || 0;
    let pipes = [];
    let gameOver = false;
    const birdImage = new Image();
    birdImage.src = 'images/91453.png'; // Putanja do va≈°e slike

    document.getElementById('flappy-highscore').textContent = highscore;

    function drawBird() {
        ctx.drawImage(birdImage, bird.x, bird.y, bird.width, bird.height);
    }

    function drawPipes() {
        ctx.fillStyle = 'green';
        pipes.forEach(pipe => {
            ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
            ctx.fillRect(pipe.x, flappyGameContainer.height - pipe.bottom, pipe.width, pipe.bottom);
        });
    }

    function calculateGap(score) {
        if (score < 14) return 200; // Lako
        if (score < 30) return 150; // Malo te≈æe
        if (score < 42) return 120; // Jo≈° te≈æe
        return 100; // Najte≈æe
    }

    function updatePipes() {
        if (pipes.length === 0 || pipes[pipes.length - 1].x < 300) {
            const gap = calculateGap(score);
            const top = Math.random() * (flappyGameContainer.height - gap - 200) + 50;
            pipes.push({ x: flappyGameContainer.width, width: 50, top, bottom: flappyGameContainer.height - top - gap });
        }

        pipes.forEach(pipe => {
            pipe.x -= 2;
        });

        pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);
    }

    function checkCollision() {
        if (bird.y <= 0 || bird.y + bird.height >= flappyGameContainer.height) {
            return true;
        }

        for (let pipe of pipes) {
            if (
                bird.x + bird.width > pipe.x &&
                bird.x < pipe.x + pipe.width &&
                (bird.y < pipe.top || bird.y + bird.height > flappyGameContainer.height - pipe.bottom)
            ) {
                return true;
            }
        }
        return false;
    }

    function gameLoop() {
        if (gameOver) return;

        ctx.clearRect(0, 0, flappyGameContainer.width, flappyGameContainer.height);

        bird.velocity += gravity;
        bird.y += bird.velocity;

        updatePipes();
        drawBird();
        drawPipes();

        if (checkCollision()) {
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('flappyHighscore', highscore);

                updateCurrentPriceForHighscore(userId, score);
                confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            }

            alert('Game Over!');
            document.body.removeChild(gameWrapper);
            document.body.removeChild(overlay);
            gameOver = true;
        }

        pipes.forEach(pipe => {
            if (pipe.x + pipe.width < bird.x && !pipe.passed) {
                pipe.passed = true;
                score++;
                document.getElementById('flappy-score').textContent = score;
            }
        });

        requestAnimationFrame(gameLoop);
    }

    document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && !gameOver) {
            bird.velocity = -8; // Postavlja brzinu prema gore
        }
    });

    flappyGameContainer.addEventListener('touchstart', () => {
        if (!gameOver) {
            bird.velocity = -8; // Postavlja brzinu prema gore
        }
    });

    gameLoop();
}





    // Uƒçitaj proizvode nakon uƒçitavanja stranice
    window.onload = () => {
        loadUserId();
        loadUserData();
        loadProducts();
        setInterval(() => {
            loadUserData();
            updateTotalCoinsSpent(); // A≈æuriranje svakih 5 sekundi
        }, 5000);
    };
    </script>

</body>
</html>




<style>




    /* Spreƒçavanje zoomiranja na mobilnim ureƒëajima */
    input,
    textarea {
        touch-action: manipulation; /* Omoguƒáava manipulaciju bez zumiranja */
        
    }
    
    
          
            /* Chat modal, smje≈°ten u donji desni ugao za desktop, full screen za mobilne ureƒëaje */
            #chat-modal {
                display: none;
                position: fixed;
                bottom: 20px;
                right: 20px;
                width: 350px;
                height: 600px;
                background-color: white;
                border: 1px solid #ccc;
                box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
                border-radius: 10px;
                z-index: 1000;
                flex-direction: column;
                overflow: hidden;
            }
    
            @media (max-width: 768px) {
        #chat-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            z-index: 1000;
            overflow: auto;
            border-radius: 0;
        }
    
        #chat-header {
            padding: 15px;
        }
    
        #chat-box {
            padding: 15px;
        }
    }
    
    
    #chat-header-title-container {
        flex-grow: 1;
        display: flex;
        align-items: center;
    }
    
    #chat-header-title {
        font-size: 16px;
        font-weight: bold;
        line-height: 2.2; /* Dodaje blagi prostor izmeƒëu redova za vertikalno centriranje */
    }
    
            /* Gornji dio sa X dugmetom za zatvaranje */
            #chat-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px;
                background-color: #5a99cd;
                color: white;
            }
    
            #close-chat {
                background: none;
                border: none;
                font-size: 1.5em;
                color: white;
                cursor: pointer;
            }
    
            #chat-box {
                display: flex;
                flex-direction: column;
                height: 100%;
            }
    
    
            #chat-message {
            width: 100px; /* Postavi ≈æeljenu ≈°irinu */
            padding: 5px; /* Smanji unutra≈°nji razmak */
            font-size: 16px; /* Smanji veliƒçinu fonta */
        }
    
            #users-list {
        display: flex;
        flex-direction: column; /* Stack users vertically */
        gap: 15px; /* Add space between users */
        padding: 10px;
    }
    
    .user-item {
        display: flex; /* Align elements horizontally */
        align-items: center; /* Center image and text vertically */
        gap: 10px; /* Space between profile image and text */
        padding: 10px;
        border-bottom: 1px solid #ccc; /* Add a separator line */
        cursor: pointer;
        transition: background-color 0.3s ease;
    }
    
    .user-item:hover {
        background-color: #3f78a9; /* Tamnija boja kada se prelazi mi≈°em */
    }
    
    
    #back-to-users {
        background: none;
        border: none;
        font-size: 20px;
        cursor: pointer;
        margin-right: 10px;
        color: #ffffff;
    }
    
    /* User info styling */
    .user-info {
        display: flex;
        flex-direction: column; /* Stack name and last message vertically */
    }
    
    .user-info .user-name {
        font-weight: bold; /* Bold the username */
        margin-bottom: 5px; /* Add space below the name */
        color: #000;
    }
    
    .user-info .last-message {
        color: #666; /* Gray color for the last message */
        font-size: 14px; /* Slightly smaller font size */
        overflow: hidden;
        text-overflow: ellipsis; /* Truncate long messages */
        white-space: nowrap; /* Prevent text from wrapping */
    }
    
    
    
    
            /* Poruke u chat prozoru */
            #messages {
                flex-grow: 1;
                overflow-y: auto;
                padding: 10px;
                border-bottom: 1px solid #ccc;
            }
    
            .message {
        display: block; /* Osigurajte da je svaki element u novom redu */
        margin: 5px 0; /* Razmak izmeƒëu poruka */
        padding: 10px; /* Unutarnji razmak za bolju ƒçitljivost */
        border-radius: 5px; /* Zaobljeni rubovi */
        word-wrap: break-word; /* Omoguƒáuje prelamanje rijeƒçi */
        max-width: 80%; /* Maksimalna ≈°irina poruke */
    }
    
    
    
            /* Donji dio s unosom poruke */
            #message-input {
        display: flex;
        gap: 10px;
        padding: 10px;
        position: sticky; /* Fiksirano na dno, ali unutar tok dokumenta */
        bottom: 0;
        width: 100%; /* Osigurava da unos zauzima cijelu ≈°irinu chata */
        background-color: white; /* Dodaj pozadinu */
        border-top: 1px solid #ccc; /* Gornja linija za odvajanje od poruka */
        box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* Blaga sjena za vizualni efekat */
        z-index: 10; /* Osiguraj da unos bude iznad poruka */
    }
    
    
    /* Unosno polje */
    #message-input input {
        flex-grow: 1;
        padding: 10px;
        border: 1px solid #ccc;
        border-radius: 5px;
    }
    
    /* Dugme za slanje */
    #message-input button {
        padding: 10px;
        background-color: #5a99cd;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    
           
           
           /* Prethodni CSS za div #messages, uz male izmjene */
    /* Kontejner za poruke */
    #messages {
        display: flex;
        flex-direction: column; /* Da poruke idu vertikalno jedna ispod druge */
        flex-grow: 1;
        overflow-y: auto; /* Omoguƒáava skrolanje poruka */
        padding-bottom: 40px; /* Dovoljno prostora ispod zadnje poruke */
        max-height: calc(100% - 70px); /* Visina poruka minus unos */
        box-sizing: border-box; /* Padding ukljuƒçen u ukupnu visinu */
    }
    
    .message {
        padding: 10px;
        border-radius: 5px;
        margin: 5px 0;
        max-width: 60%; /* Maksimalna ≈°irina poruke */
        word-wrap: break-word; /* Da tekst ne prelazi okvir poruke */
    }
    
    .message.sender {
        background-color: #5a99cd; /* Plava pozadina za logovanog korisnika */
        color: white;
        margin-left: auto; /* Pomeri poruku sendera desno */
        text-align: right; /* Tekst unutar poruke poravnaj desno */
    }
    
    .message.recipient {
        background-color: lightgray; /* Siva pozadina za drugog korisnika */
        color: black;
        margin-right: auto; /* Pomeri poruku recipienta levo */
        text-align: left; /* Tekst unutar poruke poravnaj levo */
    }
    
    
    
    
    #search-container {
        display: flex;
        align-items: center;
        margin-bottom: 20px; /* Razmak izmeƒëu pretrage i liste korisnika */
    }
    
    #user-search {
        padding: 10px;
        border-radius: 5px;
        border: 1px solid #ccc;
        width: 250px; /* ≈†irina polja za pretragu */
        font-size: 16px;
    }
    
    #search-button {
        background-color: #4CAF50; /* Zelena boja */
        color: white; /* Bijela boja teksta */
        border: none;
        padding: 10px 15px;
        border-radius: 5px;
        cursor: pointer;
        margin-left: 10px; /* Razmak izmeƒëu polja za pretragu i dugmeta */
        font-size: 16px;
        transition: background-color 0.3s ease; /* Animacija za hover */
    }
    
    
    #create-group-button {
        background-color: #4CAF50; /* Zelena boja */
        color: white; /* Bijela boja teksta */
        border: none;
        padding: 8.5px 13px;
        border-radius: 5px;
        cursor: pointer;
        margin-left: 10px; /* Razmak izmeƒëu polja za pretragu i dugmeta */
        font-size: 16px;
        transition: background-color 0.3s ease; /* Animacija za hover */
    }
    
    #search-button:hover {
        background-color: #45a049; /* Tamnija zelena kada se preƒëe mi≈°em */
    }
    
    #search-button:focus {
        outline: none; /* Uklanja plavi rub kad je dugme fokusirano */
    }
    
    
    /* Stilovi za modal */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.4); /* Crna pozadina sa transparentno≈°ƒáu */
    }
    
    .modal-content {
        background-color: white;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 400px;
        border-radius: 10px;
    }
    
    .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
    }
    
    .close:hover, .close:focus {
        color: black;
        text-decoration: none;
        cursor: pointer;
    }
    
    
    .user-item img {
        width: 50px;
        height: 50px;
        border-radius: 50%;
        object-fit: cover;
        background-color: #5a99cd; /* Fallback background */
    }
    
    
    
    .message img {
        max-width: 100px; /* Limits the width of the image */
        max-height: 100px; /* Limits the height of the image */
        border-radius: 8px; /* Adds rounded corners */
        margin-bottom: 10px; /* Adds spacing below the image */
        object-fit: cover; /* Ensures the image covers the area without being distorted */
    }
    
    /* The modal for full-screen image */
    .image-modal {
        display: none; /* Hidden by default */
        position: fixed;
        z-index: 1000; /* Ensure it appears above other elements */
        left: 0;
        top: 0;
        width: 100%; /* Full width */
        height: 100%; /* Full height */
        background-color: rgba(0, 0, 0, 0.9); /* Black background with transparency */
    }
    
    /* Image inside the modal */
    .modal-content {
        margin: auto;
        display: block;
        max-width: 90%;
        max-height: 90%;
    }
    
    /* Close button */
    .close {
        position: absolute;
        top: 20px;
        right: 35px;
        color: white;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
    }
    
    .close:hover,
    .close:focus {
        color: #bbb;
        text-decoration: none;
        cursor: pointer;
    }
    @media screen and (max-width: 768px) {
        .image-modal {
            align-items: flex-start; /* Align the image to the top */
            padding-top: 250px; /* Add padding at the top to push the image down */
        }
    
        .modal-content {
            max-width: 95%;
            max-height: 70%; /* Keep the height smaller for mobile */
        }
    }
    
    
    
    #send-image {
            width: 40px; /* ≈†irina dugmeta */
            height: 40px; /* Visina dugmeta */
            font-size: 20px; /* Veliƒçina fonta unutar dugmeta */
            background-color: #f0f0f0; /* Svijetlo siva boja pozadine */
            border: none;
            border-radius: 5px; /* Zaobljeni uglovi */
            cursor: pointer;
        }
    
        /* Smanjenje pozadine dugmeta za video poziv */
        #start-call {
            width: 40px; /* ≈†irina dugmeta */
            height: 40px; /* Visina dugmeta */
            padding: 5px; /* Manji unutra≈°nji razmak */
            font-size: 18px; /* Veliƒçina ikone */
            
            border: none;
            border-radius: 5px; /* Zaobljeni uglovi */
            cursor: pointer;
        }
    
    /* Main container for all products */
    .marketplace-outline {
        padding: 20px;
        border: 3px solid; /* Adjust border thickness */
        border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Same gradient as .product */
        background-color: #000000; /* Background color */
        border-radius: 10px;
        max-width: 1000px;
        margin: 0 auto; /* Center the container */
    }
    
    
    /* Container for individual products */
    .product {
            border: 3px solid; /* Postavite debljinu obruba */
            border-image: linear-gradient(to right, #d3d3d3, #d6d6d6) 1; /* Gradijentni obrub s lijeva na desno */
            border-radius: 8px; /* Zaobljeni uglovi */
            padding: 10px; /* Unutarnji razmak */
            margin: 10px; /* Vanjski razmak izmeƒëu proizvoda */
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1); /* Blaga sjena za bolji izgled */
        }
    
        .product img {
        width: 250px; /* Poveƒáana ≈°irina slike */
        height: 250px; /* Poveƒáana visina slike */
        object-fit: cover;
        margin-bottom: 10px;
        border-radius: 8px;
    }
    
        .product-list-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px; /* Razmak izmeƒëu proizvoda */
            justify-content: center; /* Centriranje proizvoda */
        }
    
    /* Individual product box */
    .product-box {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 200px; /* Set fixed width */
        height: 300px; /* Set fixed height */
        padding: 10px;
        background-color: #f9f9f9; /* Light background for products */
        border: 1px solid #ccc; /* Border for each product */
        border-radius: 8px;
        box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);
    }
    
    /* Image styling for each product */
    .product-box img {
        width: 100%;
        height: 150px;
        object-fit: cover;
        border-radius: 5px;
        margin-bottom: 10px;
    }
    
    /* Product name styling */
    .product-name {
        font-size: 16px;
        font-weight: bold;
        text-align: center;
        margin-bottom: 5px;
    }
    
    /* Product price styling */
    .product-price {
        font-size: 14px;
        color: #333;
        margin-bottom: 10px;
    }
    
    /* 'Kupi' button styling */
    .buy-button {
        width: 100%;
        padding: 8px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s;
    }
    
    .buy-button:hover {
        background-color: #45a049;
    }
    
    .marketplace-outline h2 {
            text-align: center; /* Centrira tekst naslova */
            margin-bottom: 20px; /* Dodaje razmak ispod naslova */
            font-weight: bold; /* Podebljava naslov */
        }
    
        /* Exchange Modal Styles */
    #exchange-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.4); /* Semi-transparent background */
    }
    
    .modal-content {
        background-color: white;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 400px;
        border-radius: 10px;
    }
    
    #exchange-modal h3 {
        text-align: center;
        font-weight: bold;
        margin-bottom: 20px;
        color: #000;
    }
    
    #coin-amount, #usd-amount {
        width: 100%;
        padding: 10px;
        margin-bottom: 15px;
        border-radius: 5px;
        border: 1px solid #ccc;
        color: #000;
    }
    
    #send-request {
        width: 100%;
        padding: 10px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
    }
    
    #send-request:hover {
        background-color: #45a049;
    }
    
    /* Buy Delta Coin Modal Styles */
    #buy-delta-modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.4); /* Semi-transparent background */
    }
    
    #buy-delta-modal .modal-content {
        background-color: white;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 80%;
        max-width: 400px;
        border-radius: 10px;
    }
    
    #buy-delta-modal h3 {
        text-align: center;
        font-weight: bold;
        margin-bottom: 20px;
        color: #000;
    }
    
    #usd-amount-buy, #delta-amount-receive {
        width: 100%;
        padding: 10px;
        margin-bottom: 15px;
        border-radius: 5px;
        border: 1px solid #ccc;
        color: #000;
    }
    
    #buy-delta-button {
        width: 100%;
        padding: 10px;
        background-color: #8A2BE2; /* Ljubiƒçasta boja */
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px; /* Opcionalno, postavlja veliƒçinu teksta */
    }
    
    #buy-delta-button:hover {
        background-color: #6a1bb5; /* Tamnija ljubiƒçasta boja na hover */
    }
    @media screen and (min-width: 768px) {
        #coin-amount, #usd-amount, #usd-amount-buy, #delta-amount-receive {
            width: 80%;
            font-size: 14px;
            margin: 10px auto; /* Razmak izmeƒëu elemenata */
            display: block; /* Osigurava prikaz jednog ispod drugog */
        }
    
        #exchange-modal .modal-content, #buy-delta-modal .modal-content {
            display: flex;
            flex-direction: column;
            align-items: center; /* Centriranje unosa u odnosu na okvir */
        }
    }
    
    /* Stilovi za `How much...` i vrijednosti */
    #exchange-modal p, #buy-delta-modal p {
        margin: 0; /* Uklanja margine izmeƒëu teksta i iznosa */
        font-size: 1em;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    #usd-amount, #delta-amount-receive {
        display: inline-block;
        margin-left: 10px; /* Razmak izmeƒëu teksta i vrijednosti */
        font-weight: bold;
    }
    
    
    .user-item {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .user-item .profile-picture {
        position: relative;
        width: 50px;
        height: 50px;
        border-radius: 50%;
        overflow: hidden;
    }
    
    
    
    /* Prilagoƒëavanje za mobilne ureƒëaje */
    @media (max-width: 600px) {
        .user-item .status-icon {
            bottom: 3px; /* Poveƒáajte ili smanjite px za fino pomjeranje */
            left: 40px; /* Poveƒáajte ili smanjite px za fino pomjeranje */
        }
    }
    
    
    #start-audio-call .material-icons,
    #start-call .material-icons {
        color: #800080; /* Ljubiƒçasta boja */
        font-size: 24px; /* Veliƒçina ikone */
        cursor: pointer;
        background: none; /* Bez pozadine */
        border: none; /* Bez ivice */
        padding: 0; /* Bez paddinga */
        outline: none; /* Ukloni outline kod fokusa */
    }
    
    #start-audio-call:hover .material-icons,
    #start-call:hover .material-icons {
        color: #a64ca6; /* Svjetlija ljubiƒçasta za hover efekt */
    }
    
    
    
    
    #message-input #start-audio-call,
    #message-input #start-call {
        display: none;
    }
    
    
    
    
    /* Styles for mobile display */
    @media (max-width: 768px) {
        #product-list {
            display: grid;
            grid-template-columns: 1fr 1fr; /* Two columns */
            gap: 10px; /* Space between products */
            transform: translateX(-10px); /* Shift the product list slightly to the left */
        }
    
        .product {
            width: 100%; /* Make each product take full width of its grid cell */
        }
    }
    
        </style>


<style>
    body {
        font-family: 'Roboto', sans-serif; /* Promjena fonta */
        color: #ffffff;
        margin: 0;
        padding: 0;
        background-color: black;
        
       
    }
   

    @media (max-width: 768px) {
    html, body {
        width: 100%;
        overflow-x: hidden; /* Onemoguƒáava horizontalno pomjeranje */
        margin: 0; /* Uklanja podrazumijevane margine */
        padding: 0; /* Uklanja podrazumijevane paddinge */
    }

    /* Osiguraj da svi kontejneri i elementi imaju odgovarajuƒáu ≈°irinu */
    * {
        max-width: 100%; /* Ograniƒçava ≈°irinu na 100% */
        box-sizing: border-box; /* Ukljuƒçuje padding i border u ukupnu ≈°irinu */
    }

    img {
        max-width: 100%; /* Odr≈æava slike unutar ≈°irine kontejnera */
        height: auto; /* Odr≈æava odnos slike */
    }

    /* Podesi ≈°irinu specifiƒçnih elemenata ako je potrebno */
    .some-element { /* Zameniti sa stvarnim klasama */
        width: 100%; /* Ili odgovarajuƒái procenat */
    }
}

    .background {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .blue {
    background: linear-gradient(to bottom right, rgba(23, 135, 226, 0.6), rgba(0, 0, 0, 0) 50%);
    position: absolute;
    top: 0;
    left: 0;
    width: 50%;
    height: 50%;
    
}


.purple {
    background: linear-gradient(to top left, rgba(128, 0, 128, 0.6), rgba(0, 0, 0, 0) 50%);
    position: fixed; /* Changed to fixed to always stick to the bottom-right */
    bottom: 0;
    right: 0;
    width: 50%;
    height: 50%;
    z-index: 1; /* Make sure it stays below other content if necessary */
}



        
    nav {
        display: flex;
        gap: 20px;
    }
    nav a {
        color: white;
        text-decoration: none;
        display: flex;
        align-items: center;
    }
    nav .material-icons {
        margin-right: 5px; /* Razmak izmeƒëu ikone i teksta */
    }
    .container {
        display: flex;
        
        padding: 20px;
    }
    .icon-section {
    flex: 2;
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 20px;
}

.icon {
    background-color: transparent; /* Prozirna pozadina */
    border-radius: 0; /* Pravougaoni oblik */
    display: flex;
    justify-content: center;
    align-items: center;
    width: 120px; /* ≈†irina pravougaonika */
    height: 60px; /* Visina pravougaonika */
    font-size: 24px;
    cursor: pointer;
    position: relative;
    background: transparent; /* Prozirna pozadina */
    color: white; /* Bijela boja teksta */
    border: 2px solid transparent; /* Prozirni obrub (outline) */
    border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Gradijentni obrub s lijeva na desno */


    

    
}

   
    .amount {
        font-size: 24px;
        margin-left: 2px;
    }


/* Stil za ikonice */
.material-icons {
    vertical-align: middle; /* Poravnanje ikone sa tekstom */
    margin-right: 8px; /* Razmak izmeƒëu ikone i teksta */
}


#share-icon {
    background-color: transparent; /* Prozirna pozadina */
    border-radius: 0; /* Pravougaoni oblik */
    display: flex;
    justify-content: center;
    align-items: center;
    width: 150px; /* ≈†irina pravougaonika */
    height: 60px; /* Visina pravougaonika */
    font-size: 22px;
    cursor: pointer;
    position: relative;
    background: transparent; /* Prozirna pozadina */
    color: white; /* Bijela boja teksta */
    border: 2px solid transparent; /* Prozirni obrub (outline) */
    border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Gradijentni obrub s lijeva na desno */


}

#share-icon span.material-icons {
    font-size: 24px; /* Veliƒçina ikone */
}

#mint-my-coin {
    background-color: transparent; /* Prozirna pozadina */
    border-radius: 0; /* Pravougaoni oblik */
    display: flex;
    justify-content: center;
    align-items: center;
    width: 150px; /* ≈†irina pravougaonika */
    height: 60px; /* Visina pravougaonika */
    font-size: 22px;
    cursor: pointer;
    position: relative;
    left: -700px; /* Pomjera ulijevo za 10px */
    background: transparent; /* Prozirna pozadina */
    color: white; /* Bijela boja teksta */
    border: 2px solid transparent; /* Prozirni obrub (outline) */
    border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Gradijentni obrub s lijeva na desno */


}


@media (max-width: 768px) {
    #mint-my-coin {
        position: relative; /* Obavezno za kori≈°tenje left i top */
        
        left: 1px;
    }
}

@media (max-width: 768px) {
    .container {
        display: flex;
        flex-direction: row; /* Elementi ostaju u istom redu */
        justify-content: space-between; /* Ravnomjeran razmak izmeƒëu elemenata */
        align-items: center; /* Centriranje elemenata vertikalno */
        gap: 10px; /* Minimalan razmak izmeƒëu elemenata */
        position: relative; /* Omoguƒáava pomjeranje */
        top: -50px; /* Pomjera cijelu grupu elemenata prema gore za 10px */
    }

    .icon, #mint-my-coin, #share-icon {
        width: auto; /* Zadr≈æava njihovu ≈°irinu */
        text-align: center; /* Poravnanje teksta centrirano */
    }
}




</style>




<style>
    .partnership-box {
        border-width: 2px; /* debljina obruba */
        border-style: solid; /* stil obruba */
        border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* gradijentni obrub s lijeva na desno */
        padding: 20px; /* razmak unutar boxa */
        margin: 20px auto; /* razmak iznad i ispod boxa, centrirano */
        max-width: 1000px; /* maksimalna ≈°irina boxa */
        text-align: justify; /* opravdanje teksta */
        background-color: #000; /* crna pozadina */
        color: #fff; /* bijela boja teksta */
        border-radius: 50px !important; /* poveƒáanje zaobljenosti ivica */
    }

    .partnership-box p {
        margin: 0; /* uklanja zadani razmak oko paragrafa */
        text-indent: 0; /* nema uvlaƒçenja prve linije */
        line-height: 1.6; /* poveƒáava razmak izmeƒëu redova */
    }

    .partnership-box img {
    width: 100%; /* Postavi osnovnu ≈°irinu na 100% da se prilagoƒëava */
    max-width: 600px; /* Maksimalna ≈°irina za desktop */
    height: auto; /* Automatsko prilagoƒëavanje visine */
}

/* Za mobilne ureƒëaje */
@media only screen and (max-width: 768px) {
    .partnership-box img {
        max-width: 350px; /* Maksimalna ≈°irina za mobitele */
    }
}

</style>




<style>
   header {

  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 20px;
  position: relative; /* Omoguƒáuje apsolutno pozicioniranje menija */
}


/* Toggle dugme */
.toggle-button {
  display: none; /* Skriveno po defaultu */
  font-size: 30px;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  margin-left: auto;
}

#toggle-menu {
  display: none; /* Skriveno po defaultu */
  flex-direction: column; /* Vertikalno poravnanje menija */
  background: linear-gradient(to bottom, #000000, #4b0078); /* Gradijent od plave do tamno ljubiƒçaste */
  position: absolute;
  right: 0px;
  top: 60px;
  width: 50%;
  box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
  z-index: 100;
}





#toggle-menu a {
  color: white;
  text-decoration: none;
  padding: 10px 20px;
  display: block;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

/* Stil za desktop meni */
/* Sakrij desktop meni po defaultu */
#desktop-menu {
  display: none; /* Uvek sakriven, kontrolisaƒáe ga JavaScript */
  flex-direction: column; /* Vertikalno poravnanje menija */
  background: linear-gradient(to bottom, #000000, #4b0078); /* Gradijent boja */
  position: absolute;
  right: 0;
  top: 60px;
  width: 12%;
  box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
  z-index: 100;
}

#desktop-menu a {
  color: white;
  text-decoration: none;
  padding: 15px 20px; /* Poveƒáan padding */
  display: block;
  text-align: center;
  font-size: 18px; /* Poveƒáana veliƒçina fonta */
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  margin-bottom: 10px; /* Dodat razmak ispod svakog linka */
}

/* Desktop dugme (toggle) */
#desktop-toggle-button {
  display: none; /* Prikazuje se samo za desktop ureƒëaje */
}

/* Prikaz desktop menija samo na veƒáim ekranima */
@media (min-width: 768px) {
  #desktop-toggle-button {
    display: block; /* Prika≈æi desktop dugme */
  }
}

/* Sakrij mobilni meni za desktop ureƒëaje */
@media (min-width: 768px) {
  #toggle-menu {
    display: none; /* Skriva mobilni meni */
  }
}

/* Mobilni meni */
@media (max-width: 768px) {
  /* Skriven desktop meni */
  #desktop-menu {
    display: none; /* Desktop meni je uvek sakriven na mobilnim ureƒëajima */
  }

  /* Prika≈æi mobilno toggle dugme */
  .toggle-button {
    display: block;
  }
}


/* Media query za mobilne ureƒëaje */
@media (max-width: 768px) {
  /* Prika≈æi toggle dugme na mobilnim ureƒëajima */
  .toggle-button {
      display: block;
      transform: translateX(20px); /* Pomjera udesno za 20px */
  }
  /* Sakrij desktop meni na mobilnim ureƒëajima */
  #desktop-menu {
      display: none;
  }

}

.image-container {
    display: flex;
    justify-content: center; /* Centriraj sliku */
    align-items: flex-start; /* Poravnaj gornji dio */
    position: relative;
}

@media (max-width: 768px) {
    .image-container {
        align-items: flex-start; /* Gornji dio */
        transform: translateY(-30px); /* Pomakni prema dolje na mobilnim ureƒëajima */
    }
}

.image-container img {
    animation: pulse 3s infinite; /* Animacija nazvana 'pulse' koja traje 2 sekunde i ponavlja se beskonaƒçno */
}

@keyframes pulse {
    0% {
        transform: scale(1); /* Poƒçetna veliƒçina */
    }
    50% {
        transform: scale(1.05); /* Blago poveƒáanje veliƒçine */
    }
    100% {
        transform: scale(1); /* Vraƒáanje na poƒçetnu veliƒçinu */
    }
}


  </style>



<style>
    #current-price {
        transform: translateX(770px); /* Podesi ovu vrijednost prema ≈æeljenom pomjeranju */
        font-weight: bold;
}

@media only screen and (max-width: 768px) {
    #current-price {
        transform: translateX(40px); /* Podesi ovu vrijednost prema ≈æeljenom pomjeranju */
    }
}

#user-name {
    position: relative;
}

@media only screen and (max-width: 768px) {
    #user-name {
        transform: translateX(-20px); /* Pomjeranje ulijevo, prilagodi prema potrebi */
    }
}


</style>
