<!DOCTYPE html>
<html lang="hr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Index</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.5.1/dist/confetti.browser.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>


    <style>

/* Spreƒçavanje zoomiranja na mobilnim ureƒëajima */
input,
textarea {
    touch-action: manipulation; /* Omoguƒáava manipulaciju bez zumiranja */
    
}


      
        /* Chat modal, smje≈°ten u donji desni ugao za desktop, full screen za mobilne ureƒëaje */
        #chat-modal {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            height: 600px;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            z-index: 1000;
            flex-direction: column;
            overflow: hidden;
        }

       

        /* Gornji dio sa X dugmetom za zatvaranje */
        #chat-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #5a99cd;
            color: white;
        }

        #close-chat {
            background: none;
            border: none;
            font-size: 1.5em;
            color: white;
            cursor: pointer;
        }

        #chat-box {
            display: flex;
            flex-direction: column;
            height: 100%;
        }


        #chat-message {
        width: 100px; /* Postavi ≈æeljenu ≈°irinu */
        padding: 5px; /* Smanji unutra≈°nji razmak */
        font-size: 14px; /* Smanji veliƒçinu fonta */
    }

        #users-list {
    display: flex;
    flex-direction: column; /* Stack users vertically */
    gap: 15px; /* Add space between users */
    padding: 10px;
}

.user-item {
    display: flex; /* Align elements horizontally */
    align-items: center; /* Center image and text vertically */
    gap: 10px; /* Space between profile image and text */
    padding: 10px;
    border-bottom: 1px solid #ccc; /* Add a separator line */
    cursor: pointer;
    transition: background-color 0.3s ease;
}

.user-item:hover {
    background-color: #3f78a9; /* Tamnija boja kada se prelazi mi≈°em */
}



/* User info styling */
.user-info {
    display: flex;
    flex-direction: column; /* Stack name and last message vertically */
}

.user-info .user-name {
    font-weight: bold; /* Bold the username */
    margin-bottom: 5px; /* Add space below the name */
}

.user-info .last-message {
    color: #666; /* Gray color for the last message */
    font-size: 14px; /* Slightly smaller font size */
    overflow: hidden;
    text-overflow: ellipsis; /* Truncate long messages */
    white-space: nowrap; /* Prevent text from wrapping */
}

        /* Poruke u chat prozoru */
        #messages {
            flex-grow: 1;
            overflow-y: auto;
            padding: 10px;
            border-bottom: 1px solid #ccc;
        }

        .message {
    display: block; /* Osigurajte da je svaki element u novom redu */
    margin: 5px 0; /* Razmak izmeƒëu poruka */
    padding: 10px; /* Unutarnji razmak za bolju ƒçitljivost */
    border-radius: 5px; /* Zaobljeni rubovi */
    word-wrap: break-word; /* Omoguƒáuje prelamanje rijeƒçi */
    max-width: 80%; /* Maksimalna ≈°irina poruke */
}



        /* Donji dio s unosom poruke */
        #message-input {
    display: flex;
    gap: 10px;
    padding: 10px;
    position: sticky; /* Fiksirano na dno, ali unutar tok dokumenta */
    bottom: 0;
    width: 100%; /* Osigurava da unos zauzima cijelu ≈°irinu chata */
    background-color: white; /* Dodaj pozadinu */
    border-top: 1px solid #ccc; /* Gornja linija za odvajanje od poruka */
    box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.1); /* Blaga sjena za vizualni efekat */
    z-index: 10; /* Osiguraj da unos bude iznad poruka */
}


/* Unosno polje */
#message-input input {
    flex-grow: 1;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
}

/* Dugme za slanje */
#message-input button {
    padding: 10px;
    background-color: #5a99cd;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
}

       
       
       /* Prethodni CSS za div #messages, uz male izmjene */
/* Kontejner za poruke */
#messages {
    display: flex;
    flex-direction: column; /* Da poruke idu vertikalno jedna ispod druge */
    flex-grow: 1;
    overflow-y: auto; /* Omoguƒáava skrolanje poruka */
    padding-bottom: 40px; /* Dovoljno prostora ispod zadnje poruke */
    max-height: calc(100% - 70px); /* Visina poruka minus unos */
    box-sizing: border-box; /* Padding ukljuƒçen u ukupnu visinu */
}

.message {
    padding: 10px;
    border-radius: 5px;
    margin: 5px 0;
    max-width: 60%; /* Maksimalna ≈°irina poruke */
    word-wrap: break-word; /* Da tekst ne prelazi okvir poruke */
}

.message.sender {
    background-color: #5a99cd; /* Plava pozadina za logovanog korisnika */
    color: white;
    margin-left: auto; /* Pomeri poruku sendera desno */
    text-align: right; /* Tekst unutar poruke poravnaj desno */
}

.message.recipient {
    background-color: lightgray; /* Siva pozadina za drugog korisnika */
    color: black;
    margin-right: auto; /* Pomeri poruku recipienta levo */
    text-align: left; /* Tekst unutar poruke poravnaj levo */
}




#search-container {
    display: flex;
    align-items: center;
    margin-bottom: 20px; /* Razmak izmeƒëu pretrage i liste korisnika */
}

#user-search {
    padding: 10px;
    border-radius: 5px;
    border: 1px solid #ccc;
    width: 250px; /* ≈†irina polja za pretragu */
    font-size: 16px;
}

#search-button {
    background-color: #4CAF50; /* Zelena boja */
    color: white; /* Bijela boja teksta */
    border: none;
    padding: 10px 15px;
    border-radius: 5px;
    cursor: pointer;
    margin-left: 10px; /* Razmak izmeƒëu polja za pretragu i dugmeta */
    font-size: 16px;
    transition: background-color 0.3s ease; /* Animacija za hover */
}

#search-button:hover {
    background-color: #45a049; /* Tamnija zelena kada se preƒëe mi≈°em */
}

#search-button:focus {
    outline: none; /* Uklanja plavi rub kad je dugme fokusirano */
}


/* Stilovi za modal */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4); /* Crna pozadina sa transparentno≈°ƒáu */
}

.modal-content {
    background-color: white;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 400px;
    border-radius: 10px;
}

.close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
}

.close:hover, .close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
}


.user-item img {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    object-fit: cover;
    background-color: #5a99cd; /* Fallback background */
}



.message img {
    max-width: 100px; /* Limits the width of the image */
    max-height: 100px; /* Limits the height of the image */
    border-radius: 8px; /* Adds rounded corners */
    margin-bottom: 10px; /* Adds spacing below the image */
    object-fit: cover; /* Ensures the image covers the area without being distorted */
}

/* The modal for full-screen image */
.image-modal {
    display: none; /* Hidden by default */
    position: fixed;
    z-index: 1000; /* Ensure it appears above other elements */
    left: 0;
    top: 0;
    width: 100%; /* Full width */
    height: 100%; /* Full height */
    background-color: rgba(0, 0, 0, 0.9); /* Black background with transparency */
}

/* Image inside the modal */
.modal-content {
    margin: auto;
    display: block;
    max-width: 90%;
    max-height: 90%;
}

/* Close button */
.close {
    position: absolute;
    top: 20px;
    right: 35px;
    color: white;
    font-size: 40px;
    font-weight: bold;
    cursor: pointer;
}

.close:hover,
.close:focus {
    color: #bbb;
    text-decoration: none;
    cursor: pointer;
}
@media screen and (max-width: 768px) {
    .image-modal {
        align-items: flex-start; /* Align the image to the top */
        padding-top: 250px; /* Add padding at the top to push the image down */
    }

    .modal-content {
        max-width: 95%;
        max-height: 70%; /* Keep the height smaller for mobile */
    }
}



#send-image {
        width: 40px; /* ≈†irina dugmeta */
        height: 40px; /* Visina dugmeta */
        font-size: 20px; /* Veliƒçina fonta unutar dugmeta */
        background-color: #f0f0f0; /* Svijetlo siva boja pozadine */
        border: none;
        border-radius: 5px; /* Zaobljeni uglovi */
        cursor: pointer;
    }

    /* Smanjenje pozadine dugmeta za video poziv */
    #start-call {
        width: 40px; /* ≈†irina dugmeta */
        height: 40px; /* Visina dugmeta */
        padding: 5px; /* Manji unutra≈°nji razmak */
        font-size: 18px; /* Veliƒçina ikone */
        background-color: rgba(0, 0, 0, 0.1); /* Smanjena pozadina */
        border: none;
        border-radius: 5px; /* Zaobljeni uglovi */
        cursor: pointer;
    }

/* Main container for all products */
.marketplace-outline {
    padding: 20px;
    border: 2px solid #ccc; /* Outer border for the entire marketplace */
    background-color: #fff; /* White background */
    border-radius: 10px;
    max-width: 1200px;
    margin: 0 auto; /* Center the container */
}

/* Container for individual products */
.product {
        border: 5px solid; /* Postavite debljinu obruba */
        border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Gradijentni obrub s lijeva na desno */
        border-radius: 8px; /* Zaobljeni uglovi */
        padding: 10px; /* Unutarnji razmak */
        margin: 10px; /* Vanjski razmak izmeƒëu proizvoda */
        display: flex;
        flex-direction: column;
        align-items: center;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.1); /* Blaga sjena za bolji izgled */
    }

    .product img {
    width: 250px; /* Poveƒáana ≈°irina slike */
    height: 250px; /* Poveƒáana visina slike */
    object-fit: cover;
    margin-bottom: 10px;
    border-radius: 8px;
}

    .product-list-container {
        display: flex;
        flex-wrap: wrap;
        gap: 10px; /* Razmak izmeƒëu proizvoda */
        justify-content: center; /* Centriranje proizvoda */
    }

/* Individual product box */
.product-box {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 200px; /* Set fixed width */
    height: 300px; /* Set fixed height */
    padding: 10px;
    background-color: #f9f9f9; /* Light background for products */
    border: 1px solid #ccc; /* Border for each product */
    border-radius: 8px;
    box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.1);
}

/* Image styling for each product */
.product-box img {
    width: 100%;
    height: 150px;
    object-fit: cover;
    border-radius: 5px;
    margin-bottom: 10px;
}

/* Product name styling */
.product-name {
    font-size: 16px;
    font-weight: bold;
    text-align: center;
    margin-bottom: 5px;
}

/* Product price styling */
.product-price {
    font-size: 14px;
    color: #333;
    margin-bottom: 10px;
}

/* 'Kupi' button styling */
.buy-button {
    width: 100%;
    padding: 8px;
    background-color: #4CAF50;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s;
}

.buy-button:hover {
    background-color: #45a049;
}

.marketplace-outline h2 {
        text-align: center; /* Centrira tekst naslova */
        margin-bottom: 20px; /* Dodaje razmak ispod naslova */
        font-weight: bold; /* Podebljava naslov */
    }
    </style>
</head>
<body>

    <header>
        <div id="user-name">Pozdrav, <span id="ime"></span></div>
        <div id="current-price">Your wallet: <span id="amount">0.00</span> &#948;</div>

    
        <!-- Toggle dugme za mobilne ureƒëaje -->
        <button id="toggle-menu-button" class="toggle-button">‚ò∞</button>
    
        <nav id="desktop-menu"> <!-- Desktop meni -->
            <a href="#"><span class="material-icons">home</span> Home</a>
            <a href="#"><span class="material-icons">group</span> Team</a>
            <a href="#" id="chat-link"><span class="material-icons">chat</span> Chat</a>
            <a href="#"><span class="material-icons">person</span> Profile</a>
        </nav>
    
        <!-- Mobilni meni -->
        <nav id="toggle-menu">
            <a href="#"><span class="material-icons">home</span> Home</a>
            <a href="#"><span class="material-icons">group</span> Team</a>
            <a href="#" id="chat-link"><span class="material-icons">chat</span> Chat</a>
            <a href="#"><span class="material-icons">person</span> Profile</a>
        </nav>
    </header>


   

    <div id="chat-modal">
        <div id="chat-header">
            <span id="chat-header-title">Chat</span>
            <button id="close-chat">‚úï</button>
            <button id="back-to-users" style="display: none;">‚Üê</button> <!-- Dodajemo dugme za povratak -->
            
        </div>
        
        <div id="chat-box">
            <div id="search-container">
                <input type="text" id="user-search" placeholder="Search users...">
                <button id="search-button">üîç</button>
            </div>
           
            <div id="users-list"></div>

        
            
            <div id="users-list"></div> <!-- Prikaz korisnika u krugovima -->
            <div id="messages" style="display: none;"></div> <!-- Skriveno dok ne odabere≈° korisnika -->
            <div id="message-input" style="display: none;">
                <button id="send-image">+</button> <!-- Dugme za dodavanje slike -->
          
                <button id="start-game" style="width: 40px; height: 40px; font-size: 20px; background-color: rgba(0, 0, 0, 0.1); border: none; border-radius: 5px; cursor: pointer;">
                    <span class="material-icons">sports_esports</span>
                </button>
                
                <button id="start-call"><span class="material-icons">videocam</span></button>


                <input type="text" id="chat-message" placeholder="Unesite poruku">
                <button id="send-message">Po≈°alji</button>
            </div>
            
        </div>
        
    </div>
    
   <!-- Modal for full-screen image -->
<div id="image-modal" class="image-modal">
    <span id="close-image-modal" class="close">&times;</span>
    <img class="modal-content" id="full-screen-image">
</div>




<div id="tic-tac-toe-board" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: white; padding: 20px; border-radius: 10px; z-index: 1000;">
    <h3 style="text-align: center;">Tic Tac Toe</h3>
    <div class="board" style="display: grid; grid-template-columns: repeat(3, 100px); gap: 5px;">
        <div class="cell" data-index="0" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="1" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="2" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="3" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="4" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="5" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="6" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="7" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
        <div class="cell" data-index="8" style="width: 100px; height: 100px; border: 1px solid #000; display: flex; align-items: center; justify-content: center; font-size: 24px; cursor: pointer;"></div>
    </div>
    <button id="close-game" style="margin-top: 10px;">Zatvori igru</button>
</div>



<script>
    document.addEventListener('click', function(event) {
    if (event.target.tagName === 'IMG' && event.target.parentElement.classList.contains('message')) {
        const modal = document.getElementById('image-modal');
        const modalImg = document.getElementById('full-screen-image');
        modal.style.display = 'block';
        modalImg.src = event.target.src; // Set the image source to the clicked image
    }
});

// Close the modal when the close button is clicked
document.getElementById('close-image-modal').addEventListener('click', function() {
    document.getElementById('image-modal').style.display = 'none';
});

</script>


    
    <script>
        const toggleMenuButton = document.getElementById('toggle-menu-button');
        const toggleMenu = document.getElementById('toggle-menu');

        toggleMenuButton.addEventListener('click', () => {
            // Togglovanje prikaza menija
            if (toggleMenu.style.display === 'flex') {
                toggleMenu.style.display = 'none'; // Sakrij meni
            } else {
                toggleMenu.style.display = 'flex'; // Prika≈æi meni
            }
        });
    </script>

   



<script>
    function scrollToBottom() {
    const messagesDiv = document.getElementById('messages');
    messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

</script>



    <div class="container">
        <div class="icon-section">
            <div class="icon" id="dolar-icon">
                <span class="material-icons">attach_money</span>
                <span class="amount">0.00/h</span>
            </div>
        </div>
        
        <!-- Dodavanje ikone za broj referral koda ispod trenutne cijene -->
        <div id="referral-info">
            <span class="material-icons" style="vertical-align: middle;">group</span> 
            <span id="referral-count">0/10</span> <!-- Prikaz broja referral koda -->
        </div>

        <!-- Ikona za dijeljenje -->
        <button id="share-icon">
            <span class="material-icons">share</span> Pozovi prijatelje
        </button>
    </div>

    <div class="image-container">
        <img src="images/delta.png" alt="Delta Image" style="max-width: 100%; height: auto;">
    </div>


    <div id="total-coins-spent" style="text-align: center; font-size: 24px; margin-top: 20px; color: white;">
        Delta Coins Majning: <span id="coins-spent">0</span>/27,000,000
    </div>
    
    

<!-- Virtuelna tr≈ænica -->
<div id="virtual-marketplace" class="marketplace-outline">
    <h2>Virtuelna tr≈ænica</h2>
    <div id="product-list" class="product-list-container">
        <!-- Individual product boxes will be added here -->
    </div>
</div>







    <div class="partnership-box">
        <p>
            Delta coin is selecting partnerships with crypto-services and general businesses ahead of our Open Network launch. 
            This is a unique, early opportunity for businesses to connect with over 10 million engaged Delta coin fans and become part of Delta‚Äôs rapidly expanding Web3 ecosystem. 
            If your company is interested in partnering with Delta or you‚Äôd like to introduce a business to partner with Delta, tap ‚ÄúPartnerships‚Äù to explore how and why.
        </p>
    </div>

   

    <div class="background blue"></div>
    <div class="background purple"></div>

    <script>
        const shareIcon = document.getElementById('share-icon');

        // Pretpostavljamo da korisniƒçko ime dolazi iz URL parametara ili je veƒá definirano
        const { username: userParam } = getQueryParams();

        // Funkcija za nativno dijeljenje
        shareIcon.addEventListener('click', async () => {
            const shareData = {
                title: 'Poziv za pridru≈æivanje',
                text: `Zdravo, pridru≈æi mi se na https://nftnox.github.io/pi9/registracija.html. Moj kod je ${userParam}`
            };

            try {
                await navigator.share(shareData);
                console.log('Uspje≈°no podijeljeno');
            } catch (err) {
                console.error('Gre≈°ka prilikom dijeljenja:', err);
            }
        });

        // Funkcija za dobijanje parametara iz URL-a
        function getQueryParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                ime: params.get('ime'),
                prezime: params.get('prezime'),
                username: params.get('username')
            };
        }
    </script>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-app.js";
        import { getFirestore, collection, getDocs, query, where, doc, getDoc, updateDoc, addDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.13.2/firebase-storage.js";

        const firebaseConfig = {
            apiKey: "AIzaSyBKfTE0qZdxVLq0lvmli367_yyqpGK-fPA",
            authDomain: "piii-7844e.firebaseapp.com",
            projectId: "piii-7844e",
            storageBucket: "piii-7844e.appspot.com",
            messagingSenderId: "315770496799",
            appId: "1:315770496799:web:0197d4baf2c8731d88722a",
            measurementId: "G-JH9SDWTS9V"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const storage = getStorage(app);



        let userId = ""; // ID trenutnog korisnika
        let username = ""; // Pravi username korisnika
        let currentPrice = 0.00; // Trenutna cijena korisnika
        let lastClickTime = null; // Vrijeme posljednjeg klika
        let referralBonus = 0.01; // Poƒçetni bonus za novog korisnika (0.01 za 5 sekundi)

        const MAX_REFERRALS = 10; // Maksimalan broj korisnika koji mogu koristiti isti referralCode

        async function loadUserId() {
            const userCollection = collection(db, 'network');
            const q = query(userCollection, where("username", "==", userParam));
            const querySnapshot = await getDocs(q);
            
            if (!querySnapshot.empty) {
                querySnapshot.forEach(doc => {
                    userId = doc.id; // Dobijanje ID-a korisnika
                    const userData = doc.data();
                    username = userData.ime; // Dobijanje stvarnog imena korisnika
                    document.getElementById('ime').innerText = username; // Prikazivanje imena korisnika
                    
                    if (userData.referralCode) {
                        checkReferral(userData.referralCode);
                    }
                    
                    loadUserData(); // Uƒçitavanje podataka nakon ≈°to imamo ID
                });
            } else {
                console.error("Korisnik ne postoji u Firestore-u.");
            }
        }

        async function checkReferral(referralCode) {
            const userCollection = collection(db, 'network');
            const q = query(userCollection, where("username", "==", referralCode));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                querySnapshot.forEach(async doc => {
                    const referralOwnerId = doc.id;
                    const referralOwnerData = doc.data();
                    const referralCount = referralOwnerData.referralCount || 0;
                    const usedByUser = referralOwnerData.usedBy || [];

                    if (usedByUser.includes(userId)) {
                        console.log(`Korisnik ${userId} je veƒá iskoristio referral kod.`);
                    } else if (referralCount >= MAX_REFERRALS) {
                        console.log(`Referral kod od korisnika ${referralOwnerData.username} je veƒá iskori≈°ten maksimalno puta.`);
                    } else {
                        const newReferralBonus = 0.01 * (referralCount + 1);

                        console.log(`Referral nagrada dodana korisniku ${referralOwnerData.username}, bonus: ${newReferralBonus}`);

                        await updateDoc(doc.ref, {
                            referralBonus: 0.01 + newReferralBonus,
                            referralCount: referralCount + 1,
                            usedBy: [...usedByUser, userId]
                        });

                        document.getElementById('referral-count').innerText = `${referralCount + 1}/${MAX_REFERRALS}`;
                    }
                });
            }
        }

        async function loadUserData() {                 //glavni dio za trenutnu cijenu//
            const docRef = doc(db, 'network', userId);
            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                currentPrice = docSnap.data().currentPrice || 0.00;
                lastClickTime = docSnap.data().lastClickTime ? docSnap.data().lastClickTime.toDate() : null;
                const userReferralBonus = docSnap.data().referralBonus || 0.01;

                document.getElementById('current-price').querySelector('#amount').innerText = currentPrice.toFixed(2);
                document.querySelector('.amount').innerText = (currentPrice > 0) ? userReferralBonus + "/h" : "0.00/h";

                const now = new Date();
                const twentyFourHours = 24 * 60 * 60 * 1000;

                if (lastClickTime) {
                    const elapsed = now - lastClickTime;
                    const increments = Math.floor(elapsed / 5000);
                    currentPrice += increments * userReferralBonus;
                    document.getElementById('amount').innerText = currentPrice.toFixed(2);
                    lastClickTime.setSeconds(lastClickTime.getSeconds() + increments * 5);
                    await updateFirestore(currentPrice, lastClickTime);
                }

                document.getElementById('dolar-icon').addEventListener('click', async () => {
                    const now = new Date();

                    if (!lastClickTime || (now - lastClickTime) >= twentyFourHours) {
                        lastClickTime = now;
                        currentPrice += userReferralBonus;
                        document.querySelector('.amount').innerText = userReferralBonus + "/h";
                        await updateFirestore(currentPrice, lastClickTime);
                    } else {
                        alert("Mo≈æete kliknuti samo jednom svakih 24 sata.");
                    }
                });
            } else {
                console.error("Korisnik ne postoji u Firestore-u.");
            }
        }

        async function updateFirestore(currentPrice, lastClickTime) {
            const docRef = doc(db, 'network', userId);
            try {
                await updateDoc(docRef, {
                    currentPrice: currentPrice,
                    lastClickTime: lastClickTime ? lastClickTime : null
                });
                console.log("Podaci uspje≈°no a≈æurirani.");
            } catch (error) {
                console.error("Gre≈°ka prilikom a≈æuriranja podataka: ", error);
            }
        }

        

// TRZNICA//
// A≈æuriraj funkciju za uƒçitavanje proizvoda
async function loadProducts() {
    const productCollection = collection(db, 'products');
    const querySnapshot = await getDocs(productCollection);
    const productList = document.getElementById('product-list');
    productList.innerHTML = '';

    if (querySnapshot.empty) {
        productList.innerHTML = 'Nema dostupnih proizvoda.';
        return;
    }

    querySnapshot.forEach(docSnap => {
        const productData = docSnap.data();
        const productId = docSnap.id; // ID proizvoda za identifikaciju

        // Kreiraj div za svaki proizvod
        const productDiv = document.createElement('div');
        productDiv.classList.add('product');

        const productImg = document.createElement('img');
        productImg.src = productData.imageUrl;
        productImg.alt = productData.name;
       

        const productName = document.createElement('div');
        productName.textContent = productData.name;

        const productPrice = document.createElement('div');
        productPrice.textContent = `Cijena: ${productData.price} Œ¥`;




  // Prika≈æi cijenu u ETH ako postoji
  const productCryptoPrice = document.createElement('div');
    if (productData.cryptoPrice) {
        productCryptoPrice.textContent = `Cijena u ETH: ${productData.cryptoPrice} ETH`;
    }

    const buyWithCryptoButton = document.createElement('button');
    buyWithCryptoButton.textContent = 'Buy with Crypto';
    buyWithCryptoButton.style.backgroundColor = 'purple';
    buyWithCryptoButton.style.color = 'white';
    buyWithCryptoButton.style.marginTop = '10px';

    // Omoguƒái MetaMask plaƒáanje
    buyWithCryptoButton.addEventListener('click', async () => {
    if (typeof window.ethereum !== 'undefined') {
        try {
            // Pove≈æite se sa MetaMask-om
            await window.ethereum.request({ method: 'eth_requestAccounts' });
            const web3 = new Web3(window.ethereum); // Inicijalizacija web3 objekta

            // Dobijanje trenutnog raƒçuna kori≈°tenjem 'eth_accounts'
            const accounts = await web3.eth.getAccounts();
            const account = accounts[0]; // Prvi raƒçun u nizu
            console.log("Povezan raƒçun:", account);

            // Provjera cijene u ETH
            const ethPrice = productData.cryptoPrice;
            console.log("Cijena u ETH:", ethPrice);

            // Konverzija cijene u wei (1 ETH = 10^18 wei)
            const weiValue = web3.utils.toWei(ethPrice.toString(), 'ether');

            // Inicijacija transakcije
            const txParams = {
                from: account,
                to: '0x045cd928A66C6FAb414c807005CFD7769470FDAf', // Va≈°a Ethereum adresa
                value: web3.utils.toHex(weiValue),
                gas: '21000'
            };

            const transactionHash = await window.ethereum.request({
                method: 'eth_sendTransaction',
                params: [txParams]
            });

            alert(`Uspje≈°na uplata! Transakcija: ${transactionHash}`);
        } catch (error) {
            console.error('Gre≈°ka prilikom MetaMask transakcije:', error);
            alert('Do≈°lo je do gre≈°ke. Poku≈°ajte ponovo.');
        }
    } else {
        alert('Molimo vas da instalirate MetaMask ekstenziju za kori≈°tenje kripto plaƒáanja.');
    }
});





        const buyButton = document.createElement('button');
        buyButton.textContent = productData.sold ? 'Prodato' : 'Kupi';
        buyButton.style.backgroundColor = productData.sold ? 'red' : 'green';
        buyButton.style.color = 'white';
        buyButton.style.marginTop = '10px';
        buyButton.disabled = productData.sold; // Onemoguƒáava dugme ako je proizvod prodan

        // Element za prikaz novog vlasnika
        const ownerDiv = document.createElement('div');
        if (productData.sold && productData.ownerName) {
            ownerDiv.textContent = `Novi vlasnik: ${productData.ownerName}`;
            ownerDiv.style.color = 'blue';
            ownerDiv.style.cursor = 'pointer';

            // Klikom na ime vlasnika otvara se njegov profil
         // U kodu za prikaz novog vlasnika
        // Kada se klikne na ime vlasnika proizvoda
        ownerDiv.addEventListener('click', () => {
    const prijavljeniKorisnik = localStorage.getItem('loggedInUser');
    const trenutnaCijena = document.getElementById('amount').innerText; // Trenutna cijena prijavljenog korisnika
    window.location.href = `profile.html?ime=${productData.ownerName}&loggedInUser=${prijavljeniKorisnik}&trenutnaCijena=${trenutnaCijena}`;
});





        }

        // Dodavanje dogaƒëaja za dugme 'Kupi'
        buyButton.addEventListener('click', async () => {
            if (productData.sold) {
                alert('Ovaj proizvod je veƒá prodan.');
                return;
            }

            if (currentPrice >= productData.price) {
                try {
                    // Kreiranje reference na dokument proizvoda
                    const productDocRef = doc(db, 'products', productId);

                    // A≈æuriraj status proizvoda na 'prodato' i vlasnika u Firestore-u
                    await updateDoc(productDocRef, {
                        sold: true,
                        owner: userId,
                        ownerName: username // Dodaj ime korisnika kao vlasnika
                    });

                    // Kreiranje reference na dokument korisnika
                    const userDocRef = doc(db, 'network', userId);

                    // Oduzimanje cijene proizvoda u Firestore-u
                    const novaCijena = currentPrice - productData.price;
                    await updateDoc(userDocRef, {
                        currentPrice: novaCijena
                    });

                    // Dodavanje proizvoda u kupovine
                    const userPurchasesRef = collection(db, `network/${userId}/purchases`);
                    await addDoc(userPurchasesRef, {
                        name: productData.name,
                        imageUrl: productData.imageUrl,
                        price: productData.price,
                        purchaseTime: new Date()
                    });

                    // A≈æuriranje prikaza trenutne cijene
                    currentPrice = novaCijena;
                    document.getElementById('amount').innerText = currentPrice.toFixed(2);

                    // Promjena boje dugmeta na crvenu i teksta na 'Prodato'
                    buyButton.textContent = 'Prodato';
                    buyButton.style.backgroundColor = 'red';
                    buyButton.disabled = true;

                    // Prikaz novog vlasnika ispod "Prodato"
                    ownerDiv.textContent = `Novi vlasnik: ${username}`;
                    ownerDiv.style.color = 'blue';
                    ownerDiv.style.cursor = 'pointer';

                    // Klikom na ime vlasnika otvara se njegov profil
                   // U kodu za prikaz novog vlasnika
ownerDiv.addEventListener('click', () => {
    window.location.href = `profile.html?ime=${productData.ownerName}`;
});


                    productDiv.appendChild(ownerDiv);

                    alert(`Kupili ste ${productData.name} za ${productData.price} Œ¥!`);
                } catch (error) {
                    console.error('Gre≈°ka prilikom a≈æuriranja Firestore-a:', error);
                    alert('Do≈°lo je do gre≈°ke. Poku≈°ajte ponovo.');
                }
            } else {
                alert('Nemate dovoljno sredstava za kupovinu ovog proizvoda.');
            }
        });

        productDiv.appendChild(productImg);
        productDiv.appendChild(productName);
        productDiv.appendChild(productPrice);
        productDiv.appendChild(buyButton);
        productDiv.appendChild(ownerDiv); // Dodaj div za vlasnika
        productDiv.appendChild(productCryptoPrice); // Prikaz cijene u ETH
        productDiv.appendChild(buyWithCryptoButton); // Dodaj dugme za kripto plaƒáanje
        productList.appendChild(productDiv);
    });
}

// Pozovi funkciju za uƒçitavanje proizvoda nakon ≈°to se stranica uƒçita
document.addEventListener('DOMContentLoaded', loadProducts);

// Spremi ime prijavljenog korisnika u localStorage
localStorage.setItem('loggedInUser', userParam);




/////////////////CHAAAAAAAAAAAAAAAAAAAAAAAAAAAAT//////////////////////////////

        let isChatOpen = false; // Pratimo da li je chat otvoren
let selectedUserName = ''; // ƒåuvamo ime trenutno odabranog korisnika
let selectedUserId = ''; // ƒåuvamo ID trenutno odabranog korisnika

// Store all users globally to filter them later
let allUsers = [];
let contacts = new Set(); // Set koristi se za eliminaciju duplikata

// Fetch only the users with whom a chat has been established
async function fetchContacts() {
    const chatRequestCollection = collection(db, 'chatRequests');

    // Upiti za chatove u kojima je korisnik requester ili recipient
    const qRequester = query(chatRequestCollection, where('accepted', '==', true), where('requester', '==', username));
    const qRecipient = query(chatRequestCollection, where('accepted', '==', true), where('recipientName', '==', username));

    contacts.clear(); // Oƒçisti prethodne kontakte

    // Dohvati sve chatove gdje je trenutni korisnik bio requester
    const querySnapshotRequester = await getDocs(qRequester);
    querySnapshotRequester.forEach(doc => {
        const chatData = doc.data();
        const contactUser = allUsers.find(user => user.userName === chatData.recipientName);
        if (contactUser) {
            contacts.add(JSON.stringify(contactUser));
        }
    });

    // Dohvati sve chatove gdje je trenutni korisnik bio recipient
    const querySnapshotRecipient = await getDocs(qRecipient);
    querySnapshotRecipient.forEach(doc => {
        const chatData = doc.data();
        const contactUser = allUsers.find(user => user.userName === chatData.requester);
        if (contactUser) {
            contacts.add(JSON.stringify(contactUser));
        }
    });

    // Prika≈æi sve kontakte sa profilnim slikama
    const uniqueContacts = Array.from(contacts).map(item => JSON.parse(item));
    displayUsers(uniqueContacts); // Prika≈æi kontakte
}


function displayUsers(users) {
    const usersListDiv = document.getElementById('users-list');
    usersListDiv.innerHTML = ''; // Oƒçisti prethodnu listu

    users.forEach(user => {
        const userElement = document.createElement('div');
        userElement.classList.add('user-item');

        // Profilna slika ili prazan krug s ikonom
        const imgElement = document.createElement('div');
        imgElement.style.width = '50px';
        imgElement.style.height = '50px';
        imgElement.style.borderRadius = '50%';
        imgElement.style.marginRight = '10px';
        imgElement.style.display = 'flex';
        imgElement.style.justifyContent = 'center';
        imgElement.style.alignItems = 'center';

        if (user.profilePictureUrl) {
            imgElement.style.backgroundImage = `url(${user.profilePictureUrl})`;
            imgElement.style.backgroundSize = 'cover';
            imgElement.style.backgroundPosition = 'center';
        } else {
            imgElement.style.backgroundColor = '#e0e0e0'; // Svijetlo siva za prazan krug
            imgElement.innerHTML = '<i class="fas fa-user" style="font-size: 20px; color: #7d7d7d;"></i>'; // Ikona korisnika
        }

        userElement.appendChild(imgElement);

        // Korisniƒçko ime i zadnja poruka
        const userInfo = document.createElement('div');
        userInfo.classList.add('user-info');
        const userName = document.createElement('div');
        userName.classList.add('user-name');
        userName.textContent = user.userName;

        const lastMessage = document.createElement('div');
        lastMessage.classList.add('last-message');
        lastMessage.textContent = user.lastMessage || 'Tap to preview';

        userInfo.appendChild(userName);
        userInfo.appendChild(lastMessage);
        userElement.appendChild(userInfo);

        // Klik za otvaranje chata s korisnikom
        userElement.addEventListener('click', () => {
            checkExistingChatRequest(user.userId, user.userName);
        });

        usersListDiv.appendChild(userElement);
    });
}



// Funkcija za pretragu korisnika prilikom unosa
document.getElementById('user-search').addEventListener('input', function () {
    const searchText = this.value.toLowerCase();

    if (searchText === '') {
        // Ako je pretraga prazna, prikazuj samo kontakte
        displayUsers(Array.from(contacts).map(item => JSON.parse(item)));
    } else {
        // Ako postoji unos u pretrazi, filtriraj sve korisnike
        const filteredUsers = allUsers.filter(user => user.userName.toLowerCase().includes(searchText));
        displayUsers(filteredUsers); // A≈æuriraj listu s filtriranim korisnicima
    }
});

// Funkcija za dohvat svih korisnika
async function fetchUsers() {
    const userCollection = collection(db, 'network');
    const querySnapshot = await getDocs(userCollection);

    allUsers = []; // Oƒçisti listu korisnika
    querySnapshot.forEach(doc => {
        const userData = doc.data();
        const userName = userData.ime;
        const userId = doc.id;
        const profilePictureUrl = userData.profilePictureUrl || ''; // Preuzimamo URL slike ako postoji

        allUsers.push({ userName, userId, profilePictureUrl });
    });

    // Nakon dohvaƒáanja svih korisnika, prika≈æi samo one s kojima je zapoƒçet razgovor
    await fetchContacts(); // Prika≈æi samo kontakte
}

// Funkcija za inicijalno uƒçitavanje kada se otvori chat modal
document.getElementById('chat-link').addEventListener('click', async () => {
    await fetchUsers(); // Uƒçitaj sve korisnike, ali prika≈æi samo one s kojima je zapoƒçet razgovor
});



// Funkcija za provjeru postojeƒáeg zahtjeva za chat izmeƒëu dva korisnika
async function checkExistingChatRequest(userId, userName) {
    selectedUserId = userId; // Dodano: Postavljanje selectedUserId
    selectedUserName = userName;
    const chatRequestCollection = collection(db, 'chatRequests');
    const q = query(chatRequestCollection, 
                    where('requester', 'in', [username, userName]), 
                    where('recipientName', 'in', [username, userName]));

    const querySnapshot = await getDocs(q);

    if (!querySnapshot.empty) {
        // Ako veƒá postoji zahtjev, prikazujemo prompt za prihvatanje
        querySnapshot.forEach(doc => {
            const requestData = doc.data();
            if (requestData.recipientName === username && !requestData.accepted) {
                showAcceptChatPrompt(requestData.requester, doc.id); // Korisnik prima zahtjev
            } else if (requestData.requester === username && !requestData.accepted) {
                alert(`ƒåekate da ${requestData.recipientName} prihvati va≈° zahtjev.`);
            } else {
                openChat(userName); // Ako je zahtjev veƒá prihvaƒáen, otvaramo chat
            }
        });
    } else {
        // Ako ne postoji zahtjev, prika≈æemo prompt za poƒçetak chata
        showChatRequestPrompt(userName, userId);
    }
}

// Funkcija za prikazivanje prozora za poƒçetak chata
function showChatRequestPrompt(userName, userId) {
    // Provjeravamo da li prozor veƒá postoji, da bismo sprijeƒçili dupli prikaz
    let existingPrompt = document.querySelector('.chat-request-prompt');
    if (existingPrompt) {
        document.body.removeChild(existingPrompt);
    }

    const chatRequestPrompt = document.createElement('div');
    chatRequestPrompt.classList.add('chat-request-prompt');
    chatRequestPrompt.style.position = 'fixed';
    chatRequestPrompt.style.top = '50%';
    chatRequestPrompt.style.left = '50%';
    chatRequestPrompt.style.transform = 'translate(-50%, -50%)';
    chatRequestPrompt.style.padding = '20px';
    chatRequestPrompt.style.backgroundColor = 'white';
    chatRequestPrompt.style.border = '1px solid black';
    chatRequestPrompt.style.zIndex = '1000'; // Osiguravamo da je prozor iznad svih ostalih elemenata

    chatRequestPrompt.innerHTML = `
        <p>≈Ωelite li zapoƒçeti chat sa ${userName}?</p>
        <button id="accept-chat-request">Da</button>
        <button id="decline-chat-request">Ne</button>
    `;

    document.body.appendChild(chatRequestPrompt);






    
    // Postavi dogaƒëaj za prihvatanje zahtjeva
    document.getElementById('accept-chat-request').addEventListener('click', () => {
        sendChatRequest(userId, userName);
        document.body.removeChild(chatRequestPrompt); // Ukloni prozor za zahtjev
    });

    // Postavi dogaƒëaj za odbijanje zahtjeva
    document.getElementById('decline-chat-request').addEventListener('click', () => {
        document.body.removeChild(chatRequestPrompt); // Ukloni prozor za zahtjev
    });
}

// Funkcija za prikazivanje prozora za prihvatanje chata
function showAcceptChatPrompt(requesterName, requestId) {
    const chatAcceptPrompt = document.createElement('div');
    chatAcceptPrompt.classList.add('chat-accept-prompt');
    chatAcceptPrompt.style.position = 'fixed';
    chatAcceptPrompt.style.top = '50%';
    chatAcceptPrompt.style.left = '50%';
    chatAcceptPrompt.style.transform = 'translate(-50%, -50%)';
    chatAcceptPrompt.style.padding = '20px';
    chatAcceptPrompt.style.backgroundColor = 'white';
    chatAcceptPrompt.style.border = '1px solid black';
    chatAcceptPrompt.style.zIndex = '1000'; // Osiguravamo da je prozor iznad svih ostalih elemenata

    chatAcceptPrompt.innerHTML = `
        <p>Korisnik ${requesterName} ≈æeli da zapoƒçne chat sa vama. Prihvatate li?</p>
        <button id="accept-chat-${requestId}">Prihvati</button>
        <button id="decline-chat-${requestId}">Odbij</button>
    `;

    document.body.appendChild(chatAcceptPrompt);

    // Prihvati zahtjev
    document.getElementById(`accept-chat-${requestId}`).addEventListener('click', () => {
        acceptChatRequest(requestId);
        document.body.removeChild(chatAcceptPrompt); // Ukloni obavje≈°tenje
    });

    // Odbij zahtjev
    document.getElementById(`decline-chat-${requestId}`).addEventListener('click', () => {
        document.body.removeChild(chatAcceptPrompt); // Ukloni obavje≈°tenje
    });
}

// Funkcija za slanje zahtjeva za chat
async function sendChatRequest(userId, userName) {
    try {
        const chatRequestCollection = collection(db, 'chatRequests');
        await addDoc(chatRequestCollection, {
            requester: username, // Logovani korisnik
            recipientId: userId, // ID korisnika kojem ≈°aljemo zahtjev
            recipientName: userName,
            accepted: false // Po defaultu nije prihvaƒáen
        });
        console.log("Zahtjev za chat uspje≈°no poslan.");
    } catch (error) {
        console.error("Gre≈°ka prilikom slanja zahtjeva:", error);
    }
}

// Funkcija za prihvatanje zahtjeva za chat
async function acceptChatRequest(requestId) {
    const requestDocRef = doc(db, 'chatRequests', requestId);
    try {
        await updateDoc(requestDocRef, { accepted: true });
        console.log("Zahtjev za chat prihvaƒáen.");
        openChat(selectedUserName); // Omoguƒái normalan chat nakon prihvatanja
    } catch (error) {
        console.error("Gre≈°ka prilikom prihvatanja zahtjeva:", error);
    }
}






// Event listener za desktop meni
document.getElementById('chat-link').addEventListener('click', async () => {
    const chatModal = document.getElementById('chat-modal');
    chatModal.style.display = 'flex'; // Prikaz modalnog prozora

    // Ako se chat otvara po prvi put, dohvatimo sve korisnike
    if (!isChatOpen) {
        await fetchUsers(); // Pozovi funkciju za dobijanje korisnika
        isChatOpen = true; // Postavljamo chat stanje kao otvoreno
    } else {
        resetChat(); // Ako je chat veƒá otvoren, resetuj na listu korisnika
    }
});

// Dodaj event listener za chat link u mobilnom meniju
document.getElementById('toggle-menu').addEventListener('click', async (event) => {
    if (event.target.id === 'chat-link') {
        document.getElementById('toggle-menu').style.display = 'none'; // Sakrij mobilni meni
        const chatModal = document.getElementById('chat-modal');
        chatModal.style.display = 'flex'; // Prikaz modalnog prozora

        // Ako se chat otvara po prvi put, dohvatimo sve korisnike
        if (!isChatOpen) {
            await fetchUsers(); // Pozovi funkciju za dobijanje korisnika
            isChatOpen = true; // Postavljamo chat stanje kao otvoreno
        } else {
            resetChat(); // Ako je chat veƒá otvoren, resetuj na listu korisnika
        }
    }
});






// Funkcija za otvaranje chat-a
function openChat(userName) {
    selectedUserName = userName;

    // Pronaƒëite ID korisnika na osnovu imena
    const user = allUsers.find(u => u.userName === userName);
    if (user) {
        selectedUserId = user.userId;
    } else {
        console.error('Korisnik nije pronaƒëen');
    }

    // Sakrij pretragu korisnika
    const searchContainer = document.getElementById('search-container');
    searchContainer.style.display = 'none';

    // Postojeƒái kod za prikazivanje chata...
    const messagesDiv = document.getElementById('messages');
    const messageInputDiv = document.getElementById('message-input');
    const usersListDiv = document.getElementById('users-list');
    const backButton = document.getElementById('back-to-users');
    const chatHeaderTitle = document.getElementById('chat-header-title');

    usersListDiv.style.display = 'none';
    messagesDiv.style.display = 'block';
    messageInputDiv.style.display = 'flex';

    chatHeaderTitle.innerText = `Chat with ${userName}`;
    backButton.style.display = 'block';

    // Uƒçitajte historiju poruka i poƒçnite slu≈°ati nove poruke
    loadMessageHistory();
    listenForNewMessages();
}




async function loadMessageHistory() {
    const messagesCollection = collection(db, 'poruke');
    const q = query(messagesCollection, 
        where('sender', 'in', [username, selectedUserName]),
        where('recipient', 'in', [username, selectedUserName])
    );
    const querySnapshot = await getDocs(q);
    
    const messagesDiv = document.getElementById('messages');
    messagesDiv.innerHTML = ''; // Oƒçisti prethodne poruke

    // Uƒçitaj poruke u niz i sortiraj po timestamp-u
    const messages = [];
    querySnapshot.forEach(doc => {
        const messageData = doc.data();
        messages.push({
            ...messageData,
            id: doc.id // Saƒçuvaj id za kasniju upotrebu ako je potrebno
        });
    });

    // Sortiraj poruke po timestamp-u
    messages.sort((a, b) => a.timestamp - b.timestamp);

    // Prika≈æi sortirane poruke
    messages.forEach(messageData => {
        const messageElement = document.createElement('div');
        messageElement.classList.add('message');

        // Provjeravamo da li je poruka slika
        if (messageData.isImage) {
            const imgElement = document.createElement('img');
            imgElement.src = messageData.message; // Postavi URL slike
            imgElement.style.maxWidth = '200px'; // Maksimalna ≈°irina slike
            imgElement.style.borderRadius = '10px'; // Zaobljeni uglovi (opciono)
            imgElement.style.marginBottom = '10px'; // Razmak ispod slike (opciono)
            messageElement.appendChild(imgElement);
        } else {
            // Ako nije slika, prikazuje tekstualnu poruku
            messageElement.innerText = `${messageData.sender}: ${messageData.message}`;
        }

        // Dodaj odgovarajuƒáu klasu za po≈°iljaoca ili primaoca
        if (messageData.sender === username) {
            messageElement.classList.add('sender');
        } else {
            messageElement.classList.add('recipient');
        }

        messagesDiv.appendChild(messageElement);
    });
}



function listenForNewMessages() {
    const messagesCollection = collection(db, 'poruke');
    const q = query(messagesCollection, 
        where('sender', 'in', [username, selectedUserName]),
        where('recipient', 'in', [username, selectedUserName])
    );

    onSnapshot(q, (querySnapshot) => {
        const messagesDiv = document.getElementById('messages');
        messagesDiv.innerHTML = ''; // Oƒçisti prethodne poruke

        // Uƒçitaj poruke u niz
        const messages = [];
        querySnapshot.forEach(doc => {
            const messageData = doc.data();
            messages.push({
                ...messageData,
                id: doc.id
            });
        });

        // Sortiraj poruke po timestamp-u
        messages.sort((a, b) => a.timestamp - b.timestamp);

        // Prika≈æi sortirane poruke
        messages.forEach(messageData => {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message');

            // Provjeravamo da li je poruka slika
            if (messageData.isImage) {
                const imgElement = document.createElement('img');
                imgElement.src = messageData.message; // Postavi URL slike
                imgElement.style.maxWidth = '200px'; // Maksimalna ≈°irina slike
                imgElement.style.borderRadius = '10px'; // Zaobljeni uglovi (opciono)
                imgElement.style.marginBottom = '10px'; // Razmak ispod slike (opciono)
                messageElement.appendChild(imgElement);
            } else {
                // Ako nije slika, prikazuje tekstualnu poruku
                messageElement.innerText = `${messageData.sender}: ${messageData.message}`;
            }

            // Dodaj odgovarajuƒáu klasu za po≈°iljaoca ili primaoca
            if (messageData.sender === username) {
                messageElement.classList.add('sender');
            } else {
                messageElement.classList.add('recipient');
            }

            messagesDiv.appendChild(messageElement);
        });

        // Automatski skroluj na dno nakon ≈°to se prika≈æu poruke
        scrollToBottom();
    });
}






// Zatvori chat kada korisnik klikne na X dugme
document.getElementById('close-chat').addEventListener('click', () => {
    closeChat(); // Zatvori chat
});

// Funkcija za zatvaranje chata
function closeChat() {
    const chatModal = document.getElementById('chat-modal');
    chatModal.style.display = 'none'; // Sakrij modalni prozor
    isChatOpen = false; // Postavi chat stanje kao zatvoreno
}

// Dodaj dogaƒëaj za povratak na listu korisnika
document.getElementById('back-to-users').addEventListener('click', () => {
    resetChat(); // Resetuj chat na listu korisnika
});

// Funkcija za resetovanje chata na poƒçetnu listu korisnika
function resetChat() {
    const usersListDiv = document.getElementById('users-list');
    const messagesDiv = document.getElementById('messages');
    const messageInputDiv = document.getElementById('message-input');
    const chatHeaderTitle = document.getElementById('chat-header-title');
    const backButton = document.getElementById('back-to-users');
    const searchContainer = document.getElementById('search-container');

    usersListDiv.style.display = 'block'; // Prika≈æi listu korisnika
    messagesDiv.style.display = 'none'; // Sakrij chat prozor
    messageInputDiv.style.display = 'none'; // Sakrij unos poruka
    chatHeaderTitle.innerText = 'Chat'; // Resetuj naslov na 'Chat'
    backButton.style.display = 'none'; // Sakrij dugme za povratak

    // Ponovo prika≈æi pretragu korisnika
    searchContainer.style.display = 'block';
}





// Funkcija za slanje poruke
async function sendMessage() {
    const messageInput = document.getElementById('chat-message');
    const messageText = messageInput.value.trim();

    if (messageText) {
        const messagesCollection = collection(db, 'poruke');
        try {
            await addDoc(messagesCollection, {
                sender: username, // Ime po≈°iljaoca
                recipient: selectedUserName, // Ime primaoca
                message: messageText, // Tekst poruke
                timestamp: new Date() // Vreme slanja poruke
            });
            console.log("Poruka uspje≈°no poslana:", messageText);
            messageInput.value = ''; // Oƒçisti unos nakon slanja

            // Automatsko skrolovanje na dno nakon slanja poruke
            scrollToBottom();
        } catch (error) {
            console.error("Gre≈°ka prilikom slanja poruke:", error);
        }
    }
}


    // Dodajte dogaƒëaj za slanje poruke kada se klikne na dugme
    document.getElementById('send-message').addEventListener('click', sendMessage);



// za korisnike da se red ne remeti//
    document.getElementById("back-to-users").addEventListener("click", function() {
    document.getElementById("users-list").style.display = "flex"; // Ponovo primjeni flexbox
    document.getElementById("messages").style.display = "none"; // Sakrij poruke
    document.getElementById("message-input").style.display = "none"; // Sakrij unos poruka
    document.getElementById("back-to-users").style.display = "none"; // Sakrij dugme za povratak
});

function openChatWithUser(userId) {
    document.getElementById("users-list").style.display = "none"; // Sakrij listu korisnika
    document.getElementById("messages").style.display = "block"; // Prikazi poruke
    document.getElementById("message-input").style.display = "flex"; // Prikazi unos poruka
    document.getElementById("back-to-users").style.display = "block"; // Prikazi dugme za povratak
}


document.getElementById('send-image').addEventListener('click', () => {
    // Otvori prozor za odabir slike
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = async (event) => {
        const file = event.target.files[0]; // Preuzimanje odabrane slike

        if (file) {
            try {
                console.log('Slika je odabrana:', file.name);
                
                // Kreiranje reference za upload slike u Firebase Storage
                const storageRef = ref(storage, 'chatImages/' + selectedUserName + '_' + file.name);
                console.log('Kreirana je referenca za Storage.');

                // Upload slike u Firebase Storage
                const snapshot = await uploadBytes(storageRef, file);
                console.log('Slika je uspje≈°no uƒçitana u Storage:', snapshot);

                // Dobijanje URL-a slike
                const imageUrl = await getDownloadURL(snapshot.ref);
                console.log('URL slike je dobijen:', imageUrl);

                // Spremanje URL-a slike kao poruka u Firestore
                const messagesCollection = collection(db, 'poruke');
                await addDoc(messagesCollection, {
                    sender: username, // Ime po≈°iljaoca
                    recipient: selectedUserName, // Ime primaoca
                    message: imageUrl, // URL slike kao poruka
                    isImage: true, // Flag koji pokazuje da je poruka slika
                    timestamp: new Date() // Vreme slanja
                });

                console.log("Slika je uspje≈°no poslana u Firestore:", imageUrl);
            } catch (error) {
                console.error("Gre≈°ka prilikom slanja slike:", error);
            }
        }
    };
    input.click(); // Otvaranje prozora za odabir datoteke
});








///////////////////////VIDEOPOZIV///////////////////////////////

// Configuration for WebRTC
const configuration = {
    iceServers: [
        {
            urls: 'stun:stun.l.google.com:19302' // Google STUN server
        }
    ]
};

// When the user clicks the call button
document.getElementById('start-call').addEventListener('click', async () => {
    if (!selectedUserId || !selectedUserName) {
        console.error('selectedUserId ili selectedUserName nisu postavljeni');
        return;
    }
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        await startCall(selectedUserId, selectedUserName, stream);
    } catch (error) {
        console.error('Gre≈°ka prilikom pokretanja poziva:', error);
    }
});


// Function to start the call
async function startCall(userId, userName, stream) {
    const callRef = collection(db, 'calls');
    const callDoc = await addDoc(callRef, {
        caller: username,
        recipientId: userId,
        recipientName: userName,
        answered: false,
        ongoing: true,
        timestamp: new Date(),
        offer: null,
        answer: null
    });

    showCallingNotification(userName);
    console.log(`Calling user ${userName}.`);

    // Add local video
    addLocalVideo(stream);

    const peerConnection = new RTCPeerConnection(configuration);

    // Add local tracks to peer connection
    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

    // Create remote stream
    const remoteStream = new MediaStream();
    // Add remote stream to video element
    addRemoteVideo(remoteStream);

    // Handle ICE candidates from the caller
    const callerCandidatesCollection = collection(callDoc, 'callerCandidates');
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            addDoc(callerCandidatesCollection, event.candidate.toJSON());
        }
    };

    // Handle remote tracks
    peerConnection.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
            remoteStream.addTrack(track);
        });
    };

    // Create offer and set local description
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);

    // Update the call document with the offer
    await updateDoc(callDoc, { offer: { type: offer.type, sdp: offer.sdp } });

    // Listen for answer
    onSnapshot(callDoc, (docSnapshot) => {
        const data = docSnapshot.data();
        if (data.answer && !peerConnection.currentRemoteDescription) {
            const answerDescription = new RTCSessionDescription(data.answer);
            peerConnection.setRemoteDescription(answerDescription);
            // Show "End Call" button for caller
            showEndCallButton(callDoc.id, peerConnection);
        }
    });

    // Listen for callee's ICE candidates
    const calleeCandidatesCollection = collection(callDoc, 'calleeCandidates');
    onSnapshot(calleeCandidatesCollection, snapshot => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const candidate = new RTCIceCandidate(change.doc.data());
                peerConnection.addIceCandidate(candidate).catch(e => {
                    console.error('Error adding received ICE candidate', e);
                });
            }
        });
    });

    console.log("Call established at caller.");
}

// Function to accept the call
async function acceptCall(callId, stream) {
    const callRef = doc(db, 'calls', callId);
    await updateDoc(callRef, { answered: true });

    const peerConnection = new RTCPeerConnection(configuration);

    // Add local tracks to peer connection
    stream.getTracks().forEach(track => peerConnection.addTrack(track, stream));

    // Add local video
    addLocalVideo(stream);

    // Create remote stream
    const remoteStream = new MediaStream();
    // Add remote stream to video element
    addRemoteVideo(remoteStream);

    // Handle ICE candidates from the callee
    const calleeCandidatesCollection = collection(callRef, 'calleeCandidates');
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            addDoc(calleeCandidatesCollection, event.candidate.toJSON());
        }
    };

    // Handle remote tracks
    peerConnection.ontrack = event => {
        event.streams[0].getTracks().forEach(track => {
            remoteStream.addTrack(track);
        });
    };

    // Get the offer
    const callDataDoc = await getDoc(callRef);
    const callData = callDataDoc.data();

    if (callData.offer) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(callData.offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        // Update the call document with the answer
        await updateDoc(callRef, { answer: { type: answer.type, sdp: answer.sdp } });
        // Show "End Call" button for callee
        showEndCallButton(callId, peerConnection);
    }

    // Listen for caller's ICE candidates
    const callerCandidatesCollection = collection(callRef, 'callerCandidates');
    onSnapshot(callerCandidatesCollection, snapshot => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const candidate = new RTCIceCandidate(change.doc.data());
                peerConnection.addIceCandidate(candidate).catch(e => {
                    console.error('Error adding received ICE candidate', e);
                });
            }
        });
    });

    console.log("Call established at callee.");
}

// Function to add local video
function addLocalVideo(stream) {
    let localVideo = document.getElementById('localVideo');
    if (!localVideo) {
        localVideo = document.createElement('video');
        localVideo.id = 'localVideo';
        localVideo.style.position = 'absolute';
        localVideo.style.bottom = '10px';
        localVideo.style.right = '10px';
        localVideo.style.width = '100px'; // Smaller local video
        localVideo.style.border = '2px solid yellow';
        localVideo.style.zIndex = '10000'; // Higher z-index to appear over remote video
        localVideo.autoplay = true;
        localVideo.muted = true;
        localVideo.playsInline = true;
        // Dodajte transformaciju za zrcaljenje
        localVideo.style.transform = 'scaleX(-1)';
        document.body.appendChild(localVideo);
    }
    localVideo.srcObject = stream;
}


// Function to add remote video
function addRemoteVideo(stream) {
    let remoteVideo = document.getElementById('remoteVideo');
    let remoteVideoBlur = document.getElementById('remoteVideoBlur');

    // Create blurred background video if it doesn't exist
    if (!remoteVideoBlur) {
        remoteVideoBlur = document.createElement('video');
        remoteVideoBlur.id = 'remoteVideoBlur';
        remoteVideoBlur.style.position = 'fixed';
        remoteVideoBlur.style.top = '0';
        remoteVideoBlur.style.left = '0';
        remoteVideoBlur.style.width = '100vw'; // Full viewport width
        remoteVideoBlur.style.height = '100vh'; // Full viewport height
        remoteVideoBlur.style.filter = 'blur(20px)'; // Apply blur effect
        remoteVideoBlur.style.transform = 'scale(1.1)'; // Slightly scale up the blurred background
        remoteVideoBlur.style.zIndex = '9998'; // Place it behind the remote video
        remoteVideoBlur.autoplay = true;
        remoteVideoBlur.playsInline = true;
        remoteVideoBlur.muted = true; // No sound for the blurred background
        document.body.appendChild(remoteVideoBlur);
    }
    remoteVideoBlur.srcObject = stream; // Set the same stream for the blurred background

    // Create main remote video
    if (!remoteVideo) {
        remoteVideo = document.createElement('video');
        remoteVideo.id = 'remoteVideo';
        remoteVideo.style.position = 'fixed';
        remoteVideo.style.top = '0';
        remoteVideo.style.left = '0';
        remoteVideo.style.width = '100vw'; // Full viewport width
        remoteVideo.style.height = '100vh'; // Full viewport height
        remoteVideo.style.objectFit = 'cover'; // Stretch the video to cover the entire frame
        remoteVideo.style.border = '2px solid red';
        remoteVideo.style.zIndex = '9999'; // Keep it above the blurred background
        remoteVideo.autoplay = true;
        remoteVideo.playsInline = true;
        document.body.appendChild(remoteVideo);
    }
    remoteVideo.srcObject = stream;
}

// Show notification that user is calling (caller side)
function showCallingNotification(recipientName) {
    const callingOverlay = document.createElement('div');
    callingOverlay.classList.add('calling-overlay');
    callingOverlay.innerHTML = 
        `<div class="calling-content">
            <p>Calling ${recipientName}...</p>
        </div>`;
    
    callingOverlay.style.position = 'fixed';
    callingOverlay.style.top = '0';
    callingOverlay.style.left = '0';
    callingOverlay.style.width = '100vw';
    callingOverlay.style.height = '100vh';
    callingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Transparent dark background
    callingOverlay.style.color = 'white';
    callingOverlay.style.display = 'flex';
    callingOverlay.style.flexDirection = 'column';
    callingOverlay.style.justifyContent = 'center';
    callingOverlay.style.alignItems = 'center';
    callingOverlay.style.zIndex = '1000';
    callingOverlay.style.fontSize = '24px';

    document.body.appendChild(callingOverlay);
}

// Function to show incoming call notification (callee side)
function showIncomingCallNotification(callerName, callId) {
    const incomingCallOverlay = document.createElement('div');
    incomingCallOverlay.classList.add('incoming-call-overlay');
    incomingCallOverlay.innerHTML = 
        `<div class="incoming-call-content">
            <p>${callerName} is calling you...</p>
            <div class="incoming-call-buttons">
                <button id="answer-call-${callId}" style="background-color: green; color: white; padding: 10px 20px; margin-right: 10px; border-radius: 5px;">Accept</button>
                <button id="decline-call-${callId}" style="background-color: red; color: white; padding: 10px 20px; border-radius: 5px;">Decline</button>
            </div>
        </div>`;
    
    incomingCallOverlay.style.position = 'fixed';
    incomingCallOverlay.style.top = '0';
    incomingCallOverlay.style.left = '0';
    incomingCallOverlay.style.width = '100vw';
    incomingCallOverlay.style.height = '100vh';
    incomingCallOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Transparent dark background
    incomingCallOverlay.style.color = 'white';
    incomingCallOverlay.style.display = 'flex';
    incomingCallOverlay.style.flexDirection = 'column';
    incomingCallOverlay.style.justifyContent = 'center';
    incomingCallOverlay.style.alignItems = 'center';
    incomingCallOverlay.style.zIndex = '1000';
    incomingCallOverlay.style.fontSize = '24px';

    document.body.appendChild(incomingCallOverlay);

    // Event for accepting the call
    document.getElementById(`answer-call-${callId}`).addEventListener('click', async () => {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        await acceptCall(callId, stream);
        document.body.removeChild(incomingCallOverlay); // Remove overlay
    });

    // Event for declining the call
    document.getElementById(`decline-call-${callId}`).addEventListener('click', () => {
        document.body.removeChild(incomingCallOverlay); // Remove overlay
        // Optionally, update call document to indicate call was declined
    });
}

// Function to show "End Call" button
// Funkcija za prikaz "End Call" dugmeta kao crvenog kruga sa bijelim "X"
function showEndCallButton(callId, peerConnection) {
    const endCallButton = document.createElement('div');
    endCallButton.id = 'end-call';
    endCallButton.style.position = 'fixed';
    endCallButton.style.bottom = '20px';
    endCallButton.style.left = '50%';
    endCallButton.style.transform = 'translateX(-50%)';
    endCallButton.style.width = '60px';
    endCallButton.style.height = '60px';
    endCallButton.style.backgroundColor = 'red';
    endCallButton.style.borderRadius = '50%';
    endCallButton.style.display = 'flex';
    endCallButton.style.justifyContent = 'center';
    endCallButton.style.alignItems = 'center';
    endCallButton.style.zIndex = '10001';
    endCallButton.style.cursor = 'pointer';

    // Dodaj bijelo "X" unutar crvenog kruga
    const xIcon = document.createElement('div');
    xIcon.style.color = 'white';
    xIcon.style.fontSize = '24px';
    xIcon.style.fontWeight = 'bold';
    xIcon.textContent = 'X';

    endCallButton.appendChild(xIcon);
    document.body.appendChild(endCallButton);

    endCallButton.addEventListener('click', async () => {
        peerConnection.close();
        await updateDoc(doc(db, 'calls', callId), { ongoing: false });
        document.body.removeChild(endCallButton);
        console.log("Call ended.");
    });
}


// Function to set up listening for incoming calls
function setupIncomingCallListener() {
    const callRef = collection(db, 'calls');
    onSnapshot(callRef, (snapshot) => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const doc = change.doc;
                const data = doc.data();
                if (!data.answered && data.recipientId === userId) {
                    console.log('Dolazni poziv od:', data.caller);
                    showIncomingCallNotification(data.caller, doc.id);
                }
            }
        });
    });
}



// Initialize listening for incoming calls
setupIncomingCallListener();






document.addEventListener('DOMContentLoaded', () => {
    const prijavljeniKorisnik = localStorage.getItem('loggedInUser');
    if (prijavljeniKorisnik) {
        document.getElementById('ime').innerText = prijavljeniKorisnik; // Prika≈æi ime prijavljenog korisnika
    }
});



async function updateTotalCoinsSpent() {
    const userCollection = collection(db, 'network');
    const querySnapshot = await getDocs(userCollection);
    let totalCoinsSpent = 0;

    querySnapshot.forEach(doc => {
        const userData = doc.data();
        const userCurrentPrice = userData.currentPrice || 0;
        totalCoinsSpent += userCurrentPrice;
    });

    // A≈æurirajte prikaz na stranici
    document.getElementById('coins-spent').innerText = totalCoinsSpent.toFixed(2);
}




///////////IGRA/////////////////

// Variables for the game
let gameId = null;
let playerSymbol = null;

// Function to send a game request
document.getElementById('start-game').addEventListener('click', async () => {
    if (!selectedUserId || !selectedUserName) {
        alert("No user selected for the game.");
        return;
    }
    try {
        // First, create the game document
        const gameDocRef = await addDoc(collection(db, 'games'), {
            players: [userId, selectedUserId],
            playerSymbols: {
                [userId]: 'X',
                [selectedUserId]: 'O'
            },
            boardState: Array(9).fill(null),
            currentPlayer: userId, // The requester starts
            gameStatus: 'in_progress',
            winner: null,
            timestamp: new Date()
        });
        gameId = gameDocRef.id;
        playerSymbol = 'X'; // The requester is 'X'

        // Then, send the game request, including the gameId
        const gameRequestRef = await addDoc(collection(db, 'gameRequests'), {
            requester: username,
            requesterId: userId,
            recipientId: selectedUserId,
            recipientName: selectedUserName,
            accepted: false,
            timestamp: new Date(),
            gameId: gameId // Include the gameId
        });
        console.log("Game request sent:", gameRequestRef.id);
        // Add listener for game acceptance
        listenForGameAcceptance(gameRequestRef.id);
        alert(`Waiting for ${selectedUserName} to accept your game request.`);
        // Start listening to the game document
        startTicTacToeGame(gameId);
    } catch (error) {
        console.error("Error sending game request:", error);
    }
});

// Function to listen for game acceptance
function listenForGameAcceptance(gameRequestId) {
    const gameRequestDocRef = doc(db, 'gameRequests', gameRequestId);
    onSnapshot(gameRequestDocRef, async (docSnapshot) => {
        const data = docSnapshot.data();
        if (data.accepted) {
            console.log("Game request accepted.");
            // The game has already been created, gameId is already set
            // We can start the game
            // Ensure that gameId is set
            if (!gameId) {
                gameId = data.gameId;
                playerSymbol = 'X'; // The requester is 'X'
                startTicTacToeGame(gameId);
            }
        }
    });
}

// Function to set up game request listener for incoming requests
function setupGameRequestListener() {
    const gameRequestRef = collection(db, 'gameRequests');
    onSnapshot(gameRequestRef, (snapshot) => {
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added') {
                const data = change.doc.data();
                if (!data.accepted && data.recipientId === userId) {
                    showIncomingGameNotification(data.requester, data.requesterId, change.doc.id);
                }
            }
        });
    });
}

// Function to show incoming game notification
function showIncomingGameNotification(requesterName, requesterId, gameRequestId) {
    const notification = document.createElement('div');
    notification.classList.add('incoming-game-notification');
    notification.innerHTML = `
        <div style="position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background-color: white; padding: 20px; border-radius: 10px; z-index: 1000;">
            <p>${requesterName} invites you to play Tic Tac Toe. Do you accept?</p>
            <button id="accept-game" style="background-color: green; color: white; padding: 10px 20px; margin-right: 10px;">Accept</button>
            <button id="decline-game" style="background-color: red; color: white; padding: 10px 20px;">Decline</button>
        </div>
    `;
    document.body.appendChild(notification);

    // Accept the game
    document.getElementById('accept-game').addEventListener('click', async () => {
        // Update the game request to accepted
        const gameRequestDocRef = doc(db, 'gameRequests', gameRequestId);
        await updateDoc(gameRequestDocRef, { accepted: true });
        // Get the gameId from the game request document
        const gameRequestDoc = await getDoc(gameRequestDocRef);
        const gameRequestData = gameRequestDoc.data();
        gameId = gameRequestData.gameId;
        playerSymbol = 'O'; // The recipient is 'O'
        document.body.removeChild(notification);
        // Start the game
        startTicTacToeGame(gameId);
    });

    // Decline the game
    document.getElementById('decline-game').addEventListener('click', () => {
        document.body.removeChild(notification);
    });
}

// Function to start the game
function startTicTacToeGame(gameId) {
    const boardDiv = document.getElementById('tic-tac-toe-board');
    const cells = document.querySelectorAll('.cell');

    boardDiv.style.display = 'block';

    const gameDocRef = doc(db, 'games', gameId);

    // Set up onSnapshot listener on the game document
    onSnapshot(gameDocRef, (docSnapshot) => {
        const data = docSnapshot.data();
        if (!data) return;

        const boardState = data.boardState;
        const currentPlayerId = data.currentPlayer;
        const gameStatus = data.gameStatus;
        const winnerId = data.winner;

        // Update the board display
        cells.forEach((cell, index) => {
            cell.textContent = boardState[index];
        });

        if (gameStatus === 'finished') {
    if (winnerId === 'draw') {
        alert('Nerije≈°eno!');
    } else {
        if (winnerId === userId) {
            alert('You won 100Œ¥ Delta Coin!');
            // Prika≈æi konfete
            showConfetti();
        } else {
            alert('You lost!');
        }
        // A≈æuriraj currentPrice za pobjednika
        updateCurrentPriceForWinner(winnerId);
    }
    boardDiv.style.display = 'none';
    resetBoard();
        } else {
            if (currentPlayerId === userId) {
                console.log('Your turn.');
            } else {
                console.log('Opponent\'s turn.');
            }
        }
    });


    // Add click events to each cell only once
    cells.forEach(cell => {
        cell.onclick = async function() {
            const index = cell.getAttribute('data-index');

            // Fetch the latest game data
            const gameDoc = await getDoc(gameDocRef);
            const data = gameDoc.data();

            // Create a copy of the boardState to avoid mutating the original
            const boardState = [...data.boardState];
            const currentPlayerId = data.currentPlayer;
            const playerSymbols = data.playerSymbols;

            if (boardState[index] || data.gameStatus !== 'in_progress') {
                // The cell is already occupied or the game is over
                alert('Cell is already occupied or the game is over.');
                return;
            }

            if (currentPlayerId !== userId) {
                // Not your turn
                alert('Not your turn.');
                return;
            }

            // Make the move
            boardState[index] = playerSymbols[userId];

            // Check if we have a winner or a draw
            const winner = checkGameWinner(boardState);

            let newGameStatus = 'in_progress';
            let newWinnerId = null;
            let nextPlayerId = data.players.find(id => id !== userId); // The other player

            if (winner) {
                newGameStatus = 'finished';
                if (winner === 'draw') {
                    newWinnerId = 'draw';
                    nextPlayerId = null;
                } else {
                    newWinnerId = userId; // The current player is the winner
                    nextPlayerId = null;
                }
            }

            // Update the game document
            await updateDoc(gameDocRef, {
                boardState: boardState,
                currentPlayer: nextPlayerId,
                gameStatus: newGameStatus,
                winner: newWinnerId
            });
        };
    });

    // Button to close the game
    document.getElementById('close-game').addEventListener('click', () => {
        boardDiv.style.display = 'none';
        resetBoard();
    });
}

// Function to check for a winner or a draw
function checkGameWinner(boardState) {
    const winningCombinations = [
        [0,1,2], [3,4,5], [6,7,8], // Rows
        [0,3,6], [1,4,7], [2,5,8], // Columns
        [0,4,8], [2,4,6]           // Diagonals
    ];

    for (let combo of winningCombinations) {
        const [a, b, c] = combo;
        if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
            return true; // We have a winner
        }
    }

    if (boardState.every(cell => cell !== null)) {
        return 'draw'; // Draw
    }

    return null; // The game is not over
}

// Function to reset the board
function resetBoard() {
    const cells = document.querySelectorAll('.cell');
    cells.forEach(cell => {
        cell.textContent = '';
    });
    gameId = null;
    playerSymbol = null;
}

// Set up listener for incoming game requests
setupGameRequestListener();


async function updateCurrentPriceForWinner(winnerUserId) {
    const userDocRef = doc(db, 'network', winnerUserId);
    try {
        const userDoc = await getDoc(userDocRef);
        if (userDoc.exists()) {
            const userData = userDoc.data();
            let currentPrice = userData.currentPrice || 0;
            currentPrice += 100; // Add 100 to the currentPrice
            await updateDoc(userDocRef, {
                currentPrice: currentPrice
            });
            console.log('Updated currentPrice for winner:', winnerUserId);

            // If the winner is the current user, update the displayed amount
            if (winnerUserId === userId) {
                document.getElementById('amount').innerText = currentPrice.toFixed(2);
            }
        } else {
            console.error('User document not found for winner:', winnerUserId);
        }
    } catch (error) {
        console.error('Error updating currentPrice for winner:', error);
    }
}


function showConfetti() {
    var duration = 5 * 1000;
    var animationEnd = Date.now() + duration;
    var defaults = { startVelocity: 30, spread: 360, ticks: 60, zIndex: 1000 };

    function randomInRange(min, max) {
        return Math.random() * (max - min) + min;
    }

    var interval = setInterval(function() {
        var timeLeft = animationEnd - Date.now();

        if (timeLeft <= 0) {
            return clearInterval(interval);
        }

        var particleCount = 50 * (timeLeft / duration);
        // Pokreni konfete iz nasumiƒçnih pozicija
        confetti(Object.assign({}, defaults, { 
            particleCount, 
            origin: { x: randomInRange(0, 1), y: Math.random() - 0.2 } 
        }));
    }, 250);
}


    // Uƒçitaj proizvode nakon uƒçitavanja stranice
    window.onload = () => {
        loadUserId();
        loadUserData();
        loadProducts();
        setInterval(() => {
            loadUserData();
            updateTotalCoinsSpent(); // A≈æuriranje svakih 5 sekundi
        }, 5000);
    };
    </script>

</body>
</html>







<style>
    body {
        font-family: 'Roboto', sans-serif; /* Promjena fonta */
        margin: 0;
        padding: 0;
        background-color: black;
        
       
    }
   

    @media (max-width: 768px) {
    html, body {
        width: 100%;
        overflow-x: hidden; /* Onemoguƒáava horizontalno pomjeranje */
        margin: 0; /* Uklanja podrazumijevane margine */
        padding: 0; /* Uklanja podrazumijevane paddinge */
    }

    /* Osiguraj da svi kontejneri i elementi imaju odgovarajuƒáu ≈°irinu */
    * {
        max-width: 100%; /* Ograniƒçava ≈°irinu na 100% */
        box-sizing: border-box; /* Ukljuƒçuje padding i border u ukupnu ≈°irinu */
    }

    img {
        max-width: 100%; /* Odr≈æava slike unutar ≈°irine kontejnera */
        height: auto; /* Odr≈æava odnos slike */
    }

    /* Podesi ≈°irinu specifiƒçnih elemenata ako je potrebno */
    .some-element { /* Zameniti sa stvarnim klasama */
        width: 100%; /* Ili odgovarajuƒái procenat */
    }
}

    .background {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .blue {
    background: linear-gradient(to bottom right, rgba(23, 135, 226, 0.6), rgba(0, 0, 0, 0) 50%);
    position: absolute;
    top: 0;
    left: 0;
    width: 50%;
    height: 50%;
    
}


.purple {
    background: linear-gradient(to top left, rgba(128, 0, 128, 0.6), rgba(0, 0, 0, 0) 50%);
    position: fixed; /* Changed to fixed to always stick to the bottom-right */
    bottom: 0;
    right: 0;
    width: 50%;
    height: 50%;
    z-index: 1; /* Make sure it stays below other content if necessary */
}



        
    nav {
        display: flex;
        gap: 20px;
    }
    nav a {
        color: white;
        text-decoration: none;
        display: flex;
        align-items: center;
    }
    nav .material-icons {
        margin-right: 5px; /* Razmak izmeƒëu ikone i teksta */
    }
    .container {
        display: flex;
        
        padding: 20px;
    }
    .icon-section {
    flex: 2;
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 20px;
}

.icon {
    background-color: transparent; /* Prozirna pozadina */
    border-radius: 0; /* Pravougaoni oblik */
    display: flex;
    justify-content: center;
    align-items: center;
    width: 120px; /* ≈†irina pravougaonika */
    height: 60px; /* Visina pravougaonika */
    font-size: 24px;
    cursor: pointer;
    position: relative;
    background: transparent; /* Prozirna pozadina */
    color: white; /* Bijela boja teksta */
    border: 2px solid transparent; /* Prozirni obrub (outline) */
    border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Gradijentni obrub s lijeva na desno */


    

    
}

   
    .amount {
        font-size: 24px;
        margin-left: 2px;
    }


/* Stil za ikonice */
.material-icons {
    vertical-align: middle; /* Poravnanje ikone sa tekstom */
    margin-right: 8px; /* Razmak izmeƒëu ikone i teksta */
}


#share-icon {
    background-color: transparent; /* Prozirna pozadina */
    border-radius: 0; /* Pravougaoni oblik */
    display: flex;
    justify-content: center;
    align-items: center;
    width: 150px; /* ≈†irina pravougaonika */
    height: 60px; /* Visina pravougaonika */
    font-size: 22px;
    cursor: pointer;
    position: relative;
    background: transparent; /* Prozirna pozadina */
    color: white; /* Bijela boja teksta */
    border: 2px solid transparent; /* Prozirni obrub (outline) */
    border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* Gradijentni obrub s lijeva na desno */


}

#share-icon span.material-icons {
    font-size: 24px; /* Veliƒçina ikone */
}


</style>




<style>
    .partnership-box {
        border-width: 2px; /* debljina obruba */
        border-style: solid; /* stil obruba */
        border-image: linear-gradient(to right, #5a99cd, #4b0078) 1; /* gradijentni obrub s lijeva na desno */
        padding: 20px; /* razmak unutar boxa */
        margin: 20px auto; /* razmak iznad i ispod boxa, centrirano */
        max-width: 600px; /* maksimalna ≈°irina boxa */
        text-align: justify; /* opravdanje teksta */
        background-color: #000; /* crna pozadina */
        color: #fff; /* bijela boja teksta */
        border-radius: 50px !important; /* poveƒáanje zaobljenosti ivica */
    }

    .partnership-box p {
        margin: 0; /* uklanja zadani razmak oko paragrafa */
        text-indent: 0; /* nema uvlaƒçenja prve linije */
        line-height: 1.6; /* poveƒáava razmak izmeƒëu redova */
    }

    .partnership-box img {
    width: 100%; /* Postavi osnovnu ≈°irinu na 100% da se prilagoƒëava */
    max-width: 600px; /* Maksimalna ≈°irina za desktop */
    height: auto; /* Automatsko prilagoƒëavanje visine */
}

/* Za mobilne ureƒëaje */
@media only screen and (max-width: 768px) {
    .partnership-box img {
        max-width: 350px; /* Maksimalna ≈°irina za mobitele */
    }
}

</style>




<style>
   header {

  color: white;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 20px;
  position: relative; /* Omoguƒáuje apsolutno pozicioniranje menija */
}


/* Toggle dugme */
.toggle-button {
  display: none; /* Skriveno po defaultu */
  font-size: 30px;
  background: none;
  border: none;
  color: white;
  cursor: pointer;
  margin-left: auto;
}

#toggle-menu {
  display: none; /* Skriveno po defaultu */
  flex-direction: column; /* Vertikalno poravnanje menija */
  background: linear-gradient(to bottom, #000000, #4b0078); /* Gradijent od plave do tamno ljubiƒçaste */
  position: absolute;
  right: 0px;
  top: 60px;
  width: 50%;
  box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
  z-index: 100;
}





#toggle-menu a {
  color: white;
  text-decoration: none;
  padding: 10px 20px;
  display: block;
  text-align: center;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

/* Stil za desktop meni */
#desktop-menu {
  display: flex;
}

#desktop-menu a {
  margin-left: 20px;
  text-decoration: none;
  color: white;
}

/* Media query za mobilne ureƒëaje */
@media (max-width: 768px) {
  /* Prika≈æi toggle dugme na mobilnim ureƒëajima */
  .toggle-button {
      display: block;
      transform: translateX(20px); /* Pomjera udesno za 20px */
  }
  /* Sakrij desktop meni na mobilnim ureƒëajima */
  #desktop-menu {
      display: none;
  }

}

.image-container {
    display: flex;
    justify-content: center; /* Centriraj sliku */
    align-items: flex-start; /* Poravnaj gornji dio */
    position: relative;
}

@media (max-width: 768px) {
    .image-container {
        align-items: flex-start; /* Gornji dio */
        transform: translateY(10px); /* Pomakni prema dolje na mobilnim ureƒëajima */
    }
}

.image-container img {
    animation: pulse 3s infinite; /* Animacija nazvana 'pulse' koja traje 2 sekunde i ponavlja se beskonaƒçno */
}

@keyframes pulse {
    0% {
        transform: scale(1); /* Poƒçetna veliƒçina */
    }
    50% {
        transform: scale(1.05); /* Blago poveƒáanje veliƒçine */
    }
    100% {
        transform: scale(1); /* Vraƒáanje na poƒçetnu veliƒçinu */
    }
}


  </style>



<style>
    #current-price {
        transform: translateX(130px); /* Podesi ovu vrijednost prema ≈æeljenom pomjeranju */
        font-weight: bold;
}

@media only screen and (max-width: 768px) {
    #current-price {
        transform: translateX(40px); /* Podesi ovu vrijednost prema ≈æeljenom pomjeranju */
    }
}

#user-name {
    position: relative;
}

@media only screen and (max-width: 768px) {
    #user-name {
        transform: translateX(-20px); /* Pomjeranje ulijevo, prilagodi prema potrebi */
    }
}


</style>
